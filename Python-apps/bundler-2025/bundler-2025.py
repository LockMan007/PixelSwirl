import os
import sys

def find_next_build_number(builds_dir):
    """Finds the next available build number by scanning the Builds directory."""
    if not os.path.exists(builds_dir):
        return 0

    max_num = -1
    for filename in os.listdir(builds_dir):
        if filename.startswith('Build-') and filename.endswith('.py'):
            try:
                num = int(filename[6:-3])
                if num > max_num:
                    max_num = num
            except ValueError:
                continue
    return max_num + 1

def find_project_files(entry_file, all_files):
    """Recursively finds all files imported by the entry file."""
    project_files = []
    visited = set()
    
    def find_dependencies(current_file):
        if current_file in visited or not current_file.endswith('.py'):
            return
        
        visited.add(current_file)
        project_files.append(current_file)

        try:
            with open(current_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('from') or line.startswith('import'):
                        parts = line.split()
                        if len(parts) >= 2 and parts[0] in ('from', 'import'):
                            module_name = parts[1].split('.')[0]
                            potential_file = f"{module_name}.py"
                            if potential_file in all_files:
                                find_dependencies(potential_file)
        except FileNotFoundError:
            print(f"Warning: Could not find dependency '{current_file}'. Skipping.")

    find_dependencies(entry_file)
    project_files.reverse()  # Ensure dependencies are written before they are used
    return project_files

def bundle_project():
    """Main function to perform the bundling process."""
    current_dir = os.getcwd()
    all_py_files = [f for f in os.listdir(current_dir) if f.endswith('.py') and f != 'bundler-2025.py']

    if not all_py_files:
        print("No Python files found in the current directory to bundle.")
        return

    print("The following files were found in the current directory:")
    for i, file in enumerate(all_py_files):
        print(f"  [{i}] {file}")
    
    while True:
        try:
            choice = input("\nWhich file is the entry point (e.g., 'main.py')? Enter the number: ")
            entry_file = all_py_files[int(choice)]
            break
        except (ValueError, IndexError):
            print("Invalid input. Please enter a valid number from the list.")

    user_files = find_project_files(entry_file, all_py_files)
    
    print("\nThe following files will be bundled:")
    for file in user_files:
        print(f"  - {file}")

    confirmation = input("Is this correct? [Y/N]: ").strip().lower()
    if confirmation != 'y':
        print("Bundling cancelled.")
        return

    builds_dir = "Builds"
    if not os.path.exists(builds_dir):
        os.makedirs(builds_dir)

    build_number = find_next_build_number(builds_dir)
    output_file = os.path.join(builds_dir, f"Build-{build_number}.py")

    with open(output_file, 'w') as out_f:
        out_f.write(f"# This file was automatically generated by bundler-2025.py\n# Build number: {build_number}\n\n")

        for file_path in user_files:
            out_f.write(f"# === Start of file: {file_path} ===\n\n")
            with open(file_path, 'r') as in_f:
                for line in in_f:
                    if not (line.strip().startswith('from') or line.strip().startswith('import')):
                        out_f.write(line)
            out_f.write(f"\n# === End of file: {file_path} ===\n\n")
    
    print(f"\nSuccessfully bundled the project into '{output_file}'.")

if __name__ == "__main__":
    bundle_project()