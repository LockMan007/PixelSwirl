<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Swirl Version 1.008</title> <style>
        body {
            font-family: Arial, sans-serif;
            display: flex; /* Changed to flex to control main content better */
            flex-direction: row; /* Main content and right panel side-by-side */
            justify-content: flex-start; /* Align content to the start (left) */
            align-items: stretch; /* Stretch children to fill height */
            background-color: #222;
            color: #eee;
            margin: 0;
            padding: 0;
            height: 100vh; /* Make body fill viewport height */
            width: 100vw; /* Make body fill viewport width */
            overflow: hidden; /* Prevent scrollbars if content slightly overflows */
            box-sizing: border-box;
        }

        .main-content-container {
            display: flex;
            flex-direction: row; 
            flex-grow: 1; /* Allows it to take up available space */
            gap: 20px; /* Space between canvas and controls (if right-panel isn't fixed) */
            align-items: flex-start; /* Align content to the top */
            height: 100%; 
            padding: 10px; /* Small padding around the main content */
            box-sizing: border-box;
            /* Removed justify-content: center to avoid pushing canvas to center if right panel is fixed */
        }

        .canvas-container {
            flex-grow: 1; /* Allows it to take available space */
            flex-shrink: 1; /* Allows it to shrink if needed */
            max-width: 100%; /* Take full available width within main-content-container */
            max-height: calc(100vh - 20px); /* Limit canvas height based on viewport and main-container padding */
            display: flex; /* Use flex to center canvas if smaller than container */
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide any overflow if image is too big for its container */
        }

        canvas {
            border: 2px solid #555;
            background-color: #000;
            display: block;
            max-width: 100%; /* Scale canvas down to fit container */
            max-height: 100%; /* Scale canvas down to fit container */
            width: auto; /* Maintain aspect ratio */
            height: auto; /* Maintain aspect ratio */
            object-fit: contain; /* Ensures image fits within bounds without cropping */
        }

        .right-panel {
            display: flex;
            flex-direction: column; /* Stack controls and title vertically */
            gap: 8px; /* Reduced gap between each control "row" */
            padding: 10px; /* Small padding inside the right panel */
            min-width: 280px; /* Ensure enough space for controls */
            flex-shrink: 0; /* Prevent the right panel from shrinking too much */
            justify-content: flex-start; /* Align items to the top */
            height: 100%; /* Take full height of main-content-container */
            box-sizing: border-box;
            background-color: #333; /* Slightly darker background for controls */
            border-radius: 8px;

            /* Docking and Locking to the right */
            position: fixed; /* Make it fixed relative to the viewport */
            right: 0; /* Align to the very right edge */
            top: 0; /* Align to the very top edge */
            height: 100vh; /* Make it fill the full viewport height */
            z-index: 1000; /* Ensure it stays on top of other content */
            padding-right: 20px; /* Add some padding on the right side of the panel itself */
            padding-left: 10px; /* Adjust left padding as needed */
            box-shadow: -5px 0 10px rgba(0,0,0,0.3); /* Optional shadow for separation */
        }

        /* Adjust main content to not be hidden behind the fixed right panel */
        .main-content-container {
            margin-right: 310px; /* Width of right-panel + its right padding + gap/buffer */
            /* This pushes the main content to the left, leaving space for the fixed right panel */
        }


        .controls-row {
            display: flex;
            flex-direction: column; /* Force each control group to its own "row" */
            gap: 4px; /* Smaller gap within a control group */
            width: 100%; /* Take full width of right-panel */
        }

        .control-group {
            display: flex;
            flex-direction: column; /* Label above input/slider */
            align-items: flex-start;
            gap: 5px;
            white-space: nowrap; /* Prevent text labels from wrapping */
            width: 100%; /* Make control group fill its row */
        }

        /* Specific styling for horizontal alignment for slider + buttons */
        .slider-with-buttons {
            display: flex;
            flex-direction: row; /* Buttons and slider side-by-side */
            align-items: center;
            gap: 5px;
            width: 100%; /* Occupy full available width */
        }

        .slider-with-value { /* New class for slider with its value span */
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px; /* Space between slider and value */
            width: 100%;
        }

        input[type="range"] {
            flex-grow: 1; /* Allow slider to take up remaining space */
            min-width: 80px; /* Ensure it doesn't get too small */
        }
        input[type="number"] {
            width: 100%; /* Make number input fill its available width */
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #555;
            background-color: #333;
            color: #eee;
            font-size: 14px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            width: 100%; /* Make buttons full width in their "row" */
            box-sizing: border-box; /* Include padding and border in width */
        }
        button:hover {
            background-color: #0056b3;
        }

        /* Styling for the new Defaults button */
        button#defaultsButton {
            background-color: #dc3545; /* Red color */
        }

        button#defaultsButton:hover {
            background-color: #c82333; /* Darker red on hover */
        }
        
        /* Styling for the new Randomize button */
        button#randomizeButton {
            background-color: #ff00ff; /* Fuchsia purple */
        }

        button#randomizeButton:hover {
            background-color: #cc00cc; /* Darker fuchsia on hover */
        }


        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            border: 1px solid #ccc;
            display: inline-block;
            padding: 10px 20px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            width: 100%; /* Make load image button full width */
            box-sizing: border-box;
            text-align: center;
        }
        .custom-file-upload:hover {
            background-color: #218838;
        }
        .checkbox-group {
            display: flex;
            flex-direction: row; /* Checkbox and label side-by-side */
            align-items: center;
            gap: 8px; /* Space between checkbox and label */
            width: 100%;
        }
        .slider-button {
            padding: 5px 10px;
            font-size: 14px;
            min-width: 30px;
            width: auto; /* Override button width for these */
            flex-shrink: 0; /* Don't let buttons shrink */
        }

        .app-info {
            margin-top: auto; /* Push to the bottom of the right panel */
            text-align: left;
            width: 100%;
            padding-top: 15px; /* Add some space above title */
            border-top: 1px solid #555; /* Separator line */
            margin-top: 15px; /* Add space above separator */
        }
        .app-info h2 {
            margin-bottom: 5px; /* Space between title and version */
            margin-top: 0;
        }
        .app-info a {
            color: #8ab4f8; /* A nice blue for links */
            text-decoration: none;
        }
        .app-info a:hover {
            text-decoration: underline;
        }
        .not-mobile {
            font-style: italic;
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="main-content-container">
        <div class="canvas-container">
            <canvas id="pixelCanvas"></canvas>
        </div>
    </div>

    <div class="right-panel">
        <div class="controls-row">
            <div class="control-group">
                <label for="imageUpload" class="custom-file-upload">Load Image</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
        </div>

        <div class="controls-row">
            <button id="restartButton">Restart</button>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="maxPiecesInput">Max # of Pieces:</label>
                <input type="number" id="maxPiecesInput" value="100000" min="4" step="1">
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="speedSlider">Piece Momentum:</label>
                <div class="slider-with-value">
                    <input type="range" id="speedSlider" min="0.1" max="5" value="1" step="0.1">
                    <span id="speedValue">1.0</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label>Puzzle Piece Size:</label>
                <div class="slider-with-buttons">
                    <button id="pixelSizeMinus" class="slider-button">-</button>
                    <input type="range" id="pixelSizeSlider" min="0" max="8" value="6" step="1">
                    <button id="pixelSizePlus" class="slider-button">+</button>
                </div>
                <span id="pixelSizeValue">64x64</span>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="gravitySlider">Gravity:</label>
                <div class="slider-with-value">
                    <input type="range" id="gravitySlider" min="0.01" max="0.5" value="0.05" step="0.001">
                    <span id="gravityValue">0.05</span>
                </div>
            </div>
        </div>
        
        <div class="controls-row">
            <div class="control-group">
                <label for="snapDistanceSlider">Snap Distance:</label>
                <div class="slider-with-value">
                    <input type="range" id="snapDistanceSlider" min="0" max="16" value="0" step="1">
                    <span id="snapDistanceValue">0 pixels</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="repelSlider">Repel:</label>
                <div class="slider-with-value">
                    <input type="range" id="repelSlider" min="0" max="1" value="0" step="0.01">
                    <span id="repelValue">0.00</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="frequencySlider">Frequency (seconds):</label>
                <div class="slider-with-value">
                    <input type="range" id="frequencySlider" min="0" max="10" value="0" step="1">
                    <span id="frequencyValue">0</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="checkbox-group">
                <input type="checkbox" id="unlockFreedomCheckbox">
                <label for="unlockFreedomCheckbox">Unlock more freedom</label>
            </div>
        </div>

        <div class="controls-row">
            <div class="checkbox-group">
                <input type="checkbox" id="unlockPieceSizeCheckbox">
                <label for="unlockPieceSizeCheckbox">Unlock Piece Size (lag)</label>
            </div>
        </div>
        
        <div class="controls-row">
            <button id="defaultsButton">Defaults</button>
        </div>

        <div class="controls-row">
            <button id="randomizeButton">Randomize</button>
        </div>

        <div class="app-info">
            <h2>Pixel Swirl</h2>
            <span id="versionNumber">Version 1.008</span>
            <span class="not-mobile">(Not for Mobile Use)</span>
            <hr> <br>
            Check out other cool stuff:<br>
            <br>
            <a href="https://pirillo.com/arcade" target="_blank">https://pirillo.com/arcade</a><br>
            <br>
            <a href="https://github.com/ChrisPirillo" target="_blank">https://github.com/ChrisPirillo</a>
            <hr> Vibe Coded with:<br>
            <a href="https://www.google.com/search?q=%22google+gemini%22" target="_blank">Gemini</a>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const imageUpload = document.getElementById('imageUpload');
        const restartButton = document.getElementById('restartButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue');
        const pixelSizeSlider = document.getElementById('pixelSizeSlider');
        const pixelSizeMinusBtn = document.getElementById('pixelSizeMinus');
        const pixelSizePlusBtn = document.getElementById('pixelSizePlus');
        const pixelSizeValueSpan = document.getElementById('pixelSizeValue');
        const gravitySlider = document.getElementById('gravitySlider');
        const gravityValueSpan = document.getElementById('gravityValue');
        const snapDistanceSlider = document.getElementById('snapDistanceSlider');
        const snapDistanceValueSpan = document.getElementById('snapDistanceValue');
        const repelSlider = document.getElementById('repelSlider');
        const repelValueSpan = document.getElementById('repelValue');
        const frequencySlider = document.getElementById('frequencySlider');
        const frequencyValueSpan = document.getElementById('frequencyValue');
        const unlockPieceSizeCheckbox = document.getElementById('unlockPieceSizeCheckbox');
        const unlockFreedomCheckbox = document.getElementById('unlockFreedomCheckbox');
        const versionNumberSpan = document.getElementById('versionNumber');
        const maxPiecesInput = document.getElementById('maxPiecesInput');
        const defaultsButton = document.getElementById('defaultsButton');
        const randomizeButton = document.getElementById('randomizeButton'); // New randomize button

        const PUZZLE_PIECE_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 16, 32, 64, 128, 256, 512];
        
        let TARGET_MAX_PIECES = 100000; 

        // Default ranges for sliders (before unlock freedom)
        const DEFAULT_SPEED_MIN = 0.1;
        const DEFAULT_SPEED_MAX = 5;
        const DEFAULT_GRAVITY_MIN = 0.01;
        const DEFAULT_GRAVITY_MAX = 0.5;
        const DEFAULT_SNAP_MIN = 0;
        const DEFAULT_SNAP_MAX = 16;
        const DEFAULT_REPEL_MIN = 0;
        const DEFAULT_REPEL_MAX = 1;
        const DEFAULT_FREQUENCY_MIN = 0;
        const DEFAULT_FREQUENCY_MAX = 10;
        const DEFAULT_PIECE_SIZE_INDEX = PUZZLE_PIECE_SIZES.indexOf(64);


        // Unlocked ranges for sliders
        const UNLOCKED_SPEED_MIN = 0.1; // Stays same
        const UNLOCKED_SPEED_MAX = 10;
        const UNLOCKED_GRAVITY_MIN = 0.001;
        const UNLOCKED_GRAVITY_MAX = 0.99;
        const UNLOCKED_SNAP_MIN = 0; // Stays same
        const UNLOCKED_SNAP_MAX = 256;
        const UNLOCKED_REPEL_MIN = 0; // Stays same
        const UNLOCKED_REPEL_MAX = 5;
        const UNLOCKED_FREQUENCY_MIN = 0; // Stays same
        const UNLOCKED_FREQUENCY_MAX = 10; // Stays same


        let gl = null;
        let program = null;
        let positionBuffer = null;
        let texCoordBuffer = null;
        let numVertices = 0;
        let animationFrameId = null;
        let originalImageObject = null;

        let currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[10];
        let animationSpeed = 1;
        let gravityForce = 0.05;
        let snapDistance = 0;
        let repelForce = 0;
        let repelFrequency = 0; // In seconds (0-10)

        let puzzlePieces = [];
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        let currentMinPieceSizeIndex = 0;

        let mainAtlasTexture = null;
        let allPositions = null;
        let allTexCoords = null;

        let lastSetPuzzlePieceSizeIndex = PUZZLE_PIECE_SIZES.indexOf(64);

        // For frequency-based repel
        let lastRepelTime = 0;
        let repelTriggeredThisFrame = false;


        // --- Shaders ---
        const vsSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            uniform mat4 u_projectionMatrix;

            void main() {
                gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec2 v_texCoord;
            uniform sampler2D u_sampler;

            void main() {
                gl_FragColor = texture2D(u_sampler, v_texCoord);
            }
        `;

        // --- WebGL Initialization ---
        function initWebGL() {
            gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('Unable to initialize WebGL. Your browser or machine may not support it.');
                alert('WebGL is not supported in your browser. This simulator requires WebGL.');
                return false;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            program = initShaderProgram(gl, vsSource, fsSource);
            if (!program) return false;

            gl.useProgram(program);

            positionBuffer = gl.createBuffer();
            texCoordBuffer = gl.createBuffer();

            return true;
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                console.error('Vertex Shader Info:', gl.getShaderInfoLog(vertexShader));
                console.error('Fragment Shader Info:', gl.getShaderInfoLog(fragmentShader));
                gl.deleteProgram(shaderProgram);
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProjectionMatrix(width, height) {
            return new Float32Array([
                2 / width, 0, 0, 0,
                0, -2 / height, 0, 0,
                0, 0, 1, 0,
                -1, 1, 0, 1
            ]);
        }

        // --- Core Logic for Particles (Puzzle Pieces) ---
        class PuzzlePiece {
            constructor(startX, startY, targetX, targetY, pieceDimension, texU0, texV0, texU1, texV1) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.dimension = pieceDimension;
                this.texCoords = [
                    texU0, texV0, // Top-Left
                    texU1, texV0, // Top-Right
                    texU0, texV1, // Bottom-Left

                    texU0, texV1, // Bottom-Left
                    texU1, texV0, // Top-Right
                    texU1, texV1  // Bottom-Right
                ];

                this.vx = 0;
                this.vy = 0;
                this.settled = false;
                this.maxSpeed = 10 * animationSpeed;
                this.damping = 0.95;
                this.swirlRadius = Math.random() * 200 + 50;
                this.swirlAngle = Math.random() * Math.PI * 2;
                this.swirlSpeed = Math.random() * 0.05 + 0.01;
            }

            update(deltaTime) {
                if (this.settled) {
                    return;
                }

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const normalizedDistance = Math.min(1, distance / 5.0 / (this.swirlRadius > 0 ? this.swirlRadius : 1));
                const swirlDampingFactor = 0.99 - (gravityForce * 0.7 * (1 - normalizedDistance));
                this.swirlRadius *= Math.max(0.7, swirlDampingFactor);

                if (distance <= snapDistance + 0.01) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.vx = 0;
                    this.vy = 0;
                    this.settled = true;
                    this.swirlRadius = 0;
                    return;
                }

                this.swirlAngle += this.swirlSpeed * animationSpeed;
                const swirlOffsetX = this.swirlRadius * Math.cos(this.swirlAngle);
                const swirlOffsetY = this.swirlRadius * Math.sin(this.swirlAngle);

                const swirlTargetX = this.targetX + swirlOffsetX;
                const swirlTargetY = this.targetY + swirlOffsetY;

                const swirlDx = swirlTargetX - this.x;
                const swirlDy = swirlTargetY - this.y;

                let effectiveForce = gravityForce * animationSpeed;

                if (repelForce > 0 && repelFrequency > 0 && repelTriggeredThisFrame) {
                     effectiveForce = -repelForce;
                }
                
                this.vx += swirlDx * effectiveForce;
                this.vy += swirlDy * effectiveForce;

                this.vx *= this.damping;
                this.vy *= this.damping;

                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > this.maxSpeed) {
                    const scale = this.maxSpeed / currentSpeed;
                    this.vx *= scale;
                    this.vy *= scale;
                }

                this.x += this.vx;
                this.y += this.vy;
                
                if (distance < 1 && this.swirlRadius < 5 && Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.settled = true;
                    this.vx = 0;
                    this.vy = 0;
                    this.swirlRadius = 0;
                }
            }
        }

        // Helper to find next power of 2
        function nextPowerOf2(n) {
            if (n === 0) return 1;
            n--;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            n++;
            return n;
        }

        // --- Setup and Rendering ---

        function resizeCanvasToImage(img) {
            canvas.width = img.width;
            canvas.height = img.height;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            const projectionMatrix = createProjectionMatrix(gl.canvas.width, gl.canvas.height);
            const uProjectionMatrixLoc = gl.getUniformLocation(program, 'u_projectionMatrix');
            gl.uniformMatrix4fv(uProjectionMatrixLoc, false, projectionMatrix);
        }

        function calculateMinPieceSizeForImage() {
            if (!originalImageObject) return;

            const imgWidth = originalImageObject.width;
            const imgHeight = originalImageObject.height;
            
            let calculatedMinIndex = 0;

            const currentTargetMaxPieces = parseInt(maxPiecesInput.value);

            for (let i = 0; i < PUZZLE_PIECE_SIZES.length; i++) {
                const p = PUZZLE_PIECE_SIZES[i];
                const pieceCountX = Math.ceil(imgWidth / p);
                const pieceCountY = Math.ceil(imgHeight / p);
                const totalPieceCount = pieceCountX * pieceCountY;

                if (totalPieceCount <= currentTargetMaxPieces) {
                    calculatedMinIndex = i;
                    break; 
                }
            }
            currentMinPieceSizeIndex = calculatedMinIndex;
            updatePieceSizeSliderRange();
        }

        function updatePieceSizeSliderRange() {
            if (unlockPieceSizeCheckbox.checked) {
                pixelSizeSlider.min = 0;
            } else {
                pixelSizeSlider.min = currentMinPieceSizeIndex;
            }

            let sliderVal = parseInt(pixelSizeSlider.value);
            const sliderMin = parseInt(pixelSizeSlider.min);
            const sliderMax = parseInt(pixelSizeSlider.max);

            let valueChanged = false;
            if (sliderVal < sliderMin) {
                pixelSizeSlider.value = sliderMin;
                valueChanged = true;
            } else if (sliderVal > sliderMax) {
                pixelSizeSlider.value = sliderMax;
                valueChanged = true;
            }
            
            if (valueChanged) {
                pixelSizeSlider.dispatchEvent(new Event('input'));
            } else {
                pixelSizeValueSpan.textContent = `${PUZZLE_PIECE_SIZES[pixelSizeSlider.value]}x${PUZZLE_PIECE_SIZES[pixelSizeSlider.value]}`;
                pixelSizeMinusBtn.disabled = parseInt(pixelSizeSlider.value) <= parseInt(pixelSizeSlider.min);
                pixelSizePlusBtn.disabled = parseInt(pixelSizeSlider.value) >= parseInt(pixelSizeSlider.max);
            }
        }


        function createPuzzlePiecesFromImage() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            let inputValue = parseInt(maxPiecesInput.value);
            if (isNaN(inputValue) || inputValue < 4) {
                inputValue = 4;
                maxPiecesInput.value = 4;
            } else {
                maxPiecesInput.value = Math.floor(inputValue);
            }
            TARGET_MAX_PIECES = inputValue;

            if (mainAtlasTexture) {
                gl.deleteTexture(mainAtlasTexture);
                mainAtlasTexture = null;
            }

            puzzlePieces = [];
            numVertices = 0;

            const imgWidth = originalImageObject.width;
            const imgHeight = originalImageObject.height;
            const pieceDim = currentPuzzlePieceSize;

            const numPiecesX = Math.ceil(imgWidth / pieceDim);
            const numPiecesY = Math.ceil(imgHeight / pieceDim);

            const atlasWidth = nextPowerOf2(numPiecesX * pieceDim);
            const atlasHeight = nextPowerOf2(numPiecesY * pieceDim);

            const atlasCanvas = document.createElement('canvas');
            const atlasCtx = atlasCanvas.getContext('2d', { willReadFrequently: true });
            atlasCanvas.width = atlasWidth;
            atlasCanvas.height = atlasHeight;
            atlasCtx.clearRect(0, 0, atlasWidth, atlasHeight);

            let pieceCount = 0;

            for (let y = 0; y < imgHeight; y += pieceDim) {
                for (let x = 0; x < imgWidth; x += pieceDim) {
                    const currentPieceSrcX = x;
                    const currentPieceSrcY = y;
                    
                    const atlasCol = Math.floor(currentPieceSrcX / pieceDim);
                    const atlasRow = Math.floor(currentPieceSrcY / pieceDim);

                    const atlasDestX = atlasCol * pieceDim;
                    const atlasDestY = atlasRow * pieceDim;

                    atlasCtx.drawImage(
                        originalImageObject,
                        currentPieceSrcX, currentPieceSrcY, pieceDim, pieceDim,
                        atlasDestX, atlasDestY, pieceDim, pieceDim
                    );
                    
                    const texU0 = atlasDestX / atlasWidth;
                    const texV0 = atlasDestY / atlasHeight;
                    const texU1 = (atlasDestX + pieceDim) / atlasWidth;
                    const texV1 = (atlasDestY + pieceDim) / atlasHeight;

                    let startX, startY;
                    const edge = Math.floor(Math.random() * 4);

                    if (edge === 0) { // Top
                        startX = Math.random() * imgWidth;
                        startY = -Math.random() * 200;
                    } else if (edge === 1) { // Right
                        startX = imgWidth + Math.random() * 200;
                        startY = Math.random() * imgHeight;
                    } else if (edge === 2) { // Bottom
                        startX = Math.random() * imgWidth;
                        startY = imgHeight + Math.random() * 200;
                    } else { // Left
                        startX = -Math.random() * 200;
                        startY = Math.random() * imgHeight;
                    }
                    
                    puzzlePieces.push(new PuzzlePiece(startX, startY, x, y, pieceDim, texU0, texV0, texU1, texV1));
                    numVertices += 6;
                    pieceCount++;
                }
            }

            mainAtlasTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, mainAtlasTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            allPositions = new Float32Array(numVertices * 2);
            allTexCoords = new Float32Array(numVertices * 2);

            let texCoordIndex = 0;
            puzzlePieces.forEach(piece => {
                for (let i = 0; i < piece.texCoords.length; i++) {
                    allTexCoords[texCoordIndex++] = piece.texCoords[i];
                }
            });

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, allTexCoords, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, allPositions.byteLength, gl.DYNAMIC_DRAW);

            console.log(`Created ${pieceCount} puzzle pieces (Total GL vertices: ${numVertices}) with dimension ${pieceDim}x${pieceDim}. Gravity: ${gravityForce}, Snap Distance: ${snapDistance}. Repel: ${repelForce}, Frequency: ${repelFrequency}. Atlas size: ${atlasWidth}x${atlasHeight}`);
            
            startAnimation();
        }

        let previousTimeStamp = 0;
        let lastRepelTriggerCheckTime = 0; // New: last time we checked if repel should be triggered
        let repelInterval = 0; // Calculated interval based on repelFrequency
        let repelImpulseDue = false; // Flag to indicate if a repel impulse is due


        function drawScene(currentTimeStamp) {
            if (!previousTimeStamp) previousTimeStamp = currentTimeStamp;
            const deltaTime = (currentTimeStamp - previousTimeStamp) / 1000; // Convert to seconds
            previousTimeStamp = currentTimeStamp;

            gl.clear(gl.COLOR_BUFFER_BIT);

            let currentPositionIndex = 0;
            let allSettled = true;

            // Determine if a repel impulse should be triggered this frame
            repelTriggeredThisFrame = false;
            if (repelForce > 0 && repelFrequency > 0) {
                // Calculate interval in milliseconds
                repelInterval = repelFrequency * 1000;

                // Only check for new impulse if enough time has passed since the last *successful* impulse or start
                if (currentTimeStamp - lastRepelTriggerCheckTime >= repelInterval) {
                    repelTriggeredThisFrame = true;
                    lastRepelTriggerCheckTime = currentTimeStamp; // Update the check time
                }
            } else {
                // If repel is off, ensure no impulses are triggered
                repelTriggeredThisFrame = false;
            }


            puzzlePieces.forEach(piece => {
                if (!piece.settled) {
                    piece.update(deltaTime);
                    allSettled = false;
                }

                const x0 = piece.x;
                const y0 = piece.y;
                const x1 = piece.x + piece.dimension;
                const y1 = piece.y + piece.dimension;

                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y0;
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y0;
                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y1;

                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y1;
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y0;
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y1;
            });

            const aPositionLoc = gl.getAttribLocation(program, 'a_position');
            const aTexCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
            const uSamplerLoc = gl.getUniformLocation(program, 'u_sampler');

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, mainAtlasTexture);
            gl.uniform1i(uSamplerLoc, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, allPositions);

            gl.enableVertexAttribArray(aPositionLoc);
            gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(aTexCoordLoc);
            gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, numVertices);

            if (!allSettled) {
                animationFrameId = requestAnimationFrame(drawScene);
            } else {
                console.log("All puzzle pieces settled.");
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (puzzlePieces.length > 0) {
                puzzlePieces.forEach(p => {
                    p.settled = false;
                    p.swirlRadius = Math.random() * 200 + 50;
                    p.swirlAngle = Math.random() * Math.PI * 2;
                    p.swirlSpeed = Math.random() * 0.05 + 0.01;
                    p.vx = 0;
                    p.vy = 0;
                });
                previousTimeStamp = 0; // Reset previous timestamp for accurate delta time
                lastRepelTriggerCheckTime = performance.now(); // Reset repel timer on animation start
                drawScene();
            }
        }

        // --- Helper for Randomization ---
        function getRandomValue(min, max, step) {
            if (step === 0) return min; // Avoid division by zero if step is 0 (shouldn't happen for ranges but as a safeguard)
            const numSteps = Math.floor((max - min) / step);
            const randomStep = Math.round(Math.random() * numSteps);
            let value = min + randomStep * step;
            // Correct for floating point inaccuracies for display
            const precision = (step.toString().split('.')[1] || '').length;
            return parseFloat(value.toFixed(precision));
        }

        // --- Event Listeners ---

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImageObject = img;
                        resizeCanvasToImage(img);
                        
                        lastSetPuzzlePieceSizeIndex = parseInt(pixelSizeSlider.value);

                        calculateMinPieceSizeForImage(); 
                        
                        pixelSizeSlider.value = Math.max(lastSetPuzzlePieceSizeIndex, currentMinPieceSizeIndex);
                        pixelSizeSlider.dispatchEvent(new Event('input'));
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        restartButton.addEventListener('click', () => {
            if (originalImageObject) {
                let inputValue = parseInt(maxPiecesInput.value);
                if (isNaN(inputValue) || inputValue < 4) {
                    inputValue = 4;
                    maxPiecesInput.value = 4;
                } else {
                    maxPiecesInput.value = Math.floor(inputValue);
                }
                TARGET_MAX_PIECES = inputValue;
                
                calculateMinPieceSizeForImage(); 
                
                pixelSizeSlider.value = Math.max(lastSetPuzzlePieceSizeIndex, currentMinPieceSizeIndex);
                pixelSizeSlider.dispatchEvent(new Event('input'));
            } else {
                alert("Please load an image first!");
            }
        });

        speedSlider.addEventListener('input', (event) => {
            animationSpeed = parseFloat(event.target.value);
            speedValueSpan.textContent = animationSpeed.toFixed(1);
            puzzlePieces.forEach(p => {
                p.maxSpeed = 10 * animationSpeed;
            });
            if (animationFrameId === null && originalImageObject) {
                 startAnimation();
            }
        });

        pixelSizeSlider.addEventListener('input', (event) => {
            const sliderIndex = parseInt(event.target.value);
            currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[sliderIndex];
            pixelSizeValueSpan.textContent = `${currentPuzzlePieceSize}x${currentPuzzlePieceSize}`;
            lastSetPuzzlePieceSizeIndex = sliderIndex;
            if (originalImageObject) {
                createPuzzlePiecesFromImage(); 
            }
            updatePieceSizeSliderRange();
        });

        pixelSizeMinusBtn.addEventListener('click', () => {
            const currentValue = parseInt(pixelSizeSlider.value);
            const minValue = parseInt(pixelSizeSlider.min);
            if (currentValue > minValue) {
                pixelSizeSlider.value = currentValue - 1;
                pixelSizeSlider.dispatchEvent(new Event('input'));
            }
        });

        pixelSizePlusBtn.addEventListener('click', () => {
            const currentValue = parseInt(pixelSizeSlider.value);
            const maxValue = parseInt(pixelSizeSlider.max);
            if (currentValue < maxValue) {
                pixelSizeSlider.value = currentValue + 1;
                pixelSizeSlider.dispatchEvent(new Event('input'));
            }
        });

        gravitySlider.addEventListener('input', (event) => {
            gravityForce = parseFloat(event.target.value);
            // Dynamic precision for display based on current value
            gravityValueSpan.textContent = gravityForce.toFixed(gravityForce < 0.01 ? 3 : 2);
            if (animationFrameId === null && originalImageObject) {
                 startAnimation();
            }
        });

        snapDistanceSlider.addEventListener('input', (event) => {
            snapDistance = parseFloat(event.target.value);
            snapDistanceValueSpan.textContent = `${snapDistance} pixels`;
        });

        repelSlider.addEventListener('input', (event) => {
            repelForce = parseFloat(event.target.value);
            repelValueSpan.textContent = repelForce.toFixed(2);
            if (animationFrameId === null && originalImageObject) {
                startAnimation();
            }
        });

        frequencySlider.addEventListener('input', (event) => {
            repelFrequency = parseInt(event.target.value);
            frequencyValueSpan.textContent = repelFrequency.toString();
            if (repelFrequency > 0) {
                 lastRepelTriggerCheckTime = performance.now(); // Reset on change
            }
            if (animationFrameId === null && originalImageObject) {
                startAnimation();
            }
        });


        unlockPieceSizeCheckbox.addEventListener('change', () => {
            updatePieceSizeSliderRange();
        });

        unlockFreedomCheckbox.addEventListener('change', (event) => {
            const checked = event.target.checked;
            
            speedSlider.min = checked ? UNLOCKED_SPEED_MIN : DEFAULT_SPEED_MIN;
            speedSlider.max = checked ? UNLOCKED_SPEED_MAX : DEFAULT_SPEED_MAX;
            gravitySlider.min = checked ? UNLOCKED_GRAVITY_MIN : DEFAULT_GRAVITY_MIN;
            gravitySlider.max = checked ? UNLOCKED_GRAVITY_MAX : DEFAULT_GRAVITY_MAX;
            snapDistanceSlider.min = checked ? UNLOCKED_SNAP_MIN : DEFAULT_SNAP_MIN;
            snapDistanceSlider.max = checked ? UNLOCKED_SNAP_MAX : DEFAULT_SNAP_MAX;
            repelSlider.min = checked ? UNLOCKED_REPEL_MIN : DEFAULT_REPEL_MIN;
            repelSlider.max = checked ? UNLOCKED_REPEL_MAX : DEFAULT_REPEL_MAX;
            frequencySlider.min = checked ? UNLOCKED_FREQUENCY_MIN : DEFAULT_FREQUENCY_MIN;
            frequencySlider.max = checked ? UNLOCKED_FREQUENCY_MAX : DEFAULT_FREQUENCY_MAX;


            // Ensure values are within new bounds and update display by dispatching input events
            speedSlider.value = Math.min(Math.max(parseFloat(speedSlider.value), parseFloat(speedSlider.min)), parseFloat(speedSlider.max));
            speedSlider.dispatchEvent(new Event('input'));
            
            gravitySlider.value = Math.min(Math.max(parseFloat(gravitySlider.value), parseFloat(gravitySlider.min)), parseFloat(gravitySlider.max));
            gravitySlider.dispatchEvent(new Event('input'));

            snapDistanceSlider.value = Math.min(Math.max(parseFloat(snapDistanceSlider.value), parseFloat(snapDistanceSlider.min)), parseFloat(snapDistanceSlider.max));
            snapDistanceSlider.dispatchEvent(new Event('input'));

            repelSlider.value = Math.min(Math.max(parseFloat(repelSlider.value), parseFloat(repelSlider.min)), parseFloat(repelSlider.max));
            repelSlider.dispatchEvent(new Event('input'));

            frequencySlider.value = Math.min(Math.max(parseFloat(frequencySlider.value), parseFloat(frequencySlider.min)), parseFloat(frequencySlider.max));
            frequencySlider.dispatchEvent(new Event('input'));
        });


        maxPiecesInput.addEventListener('change', () => {
            let inputValue = parseInt(maxPiecesInput.value);
            if (isNaN(inputValue) || inputValue < 4) {
                maxPiecesInput.value = 4;
            } else {
                maxPiecesInput.value = Math.floor(inputValue);
            }
            console.log("Max # of Pieces changed to:", maxPiecesInput.value, "Will apply on Restart.");
        });

        defaultsButton.addEventListener('click', () => {
            // Reset all sliders to their default initial values
            speedSlider.value = DEFAULT_SPEED_MIN; // Set to actual default min
            gravitySlider.value = DEFAULT_GRAVITY_MIN; // Set to actual default min
            snapDistanceSlider.value = DEFAULT_SNAP_MIN; // Set to actual default min
            repelSlider.value = DEFAULT_REPEL_MIN; // Set to actual default min
            frequencySlider.value = DEFAULT_FREQUENCY_MIN; // Set to actual default min
            maxPiecesInput.value = 100000;
            pixelSizeSlider.value = DEFAULT_PIECE_SIZE_INDEX;
            lastSetPuzzlePieceSizeIndex = DEFAULT_PIECE_SIZE_INDEX;

            // Reset checkboxes
            unlockFreedomCheckbox.checked = false;
            unlockPieceSizeCheckbox.checked = false;

            // Trigger change events to update UI and apply values
            unlockFreedomCheckbox.dispatchEvent(new Event('change')); // Do this first to reset ranges
            speedSlider.dispatchEvent(new Event('input'));
            gravitySlider.dispatchEvent(new Event('input'));
            snapDistanceSlider.dispatchEvent(new Event('input'));
            repelSlider.dispatchEvent(new Event('input'));
            frequencySlider.dispatchEvent(new Event('input'));
            maxPiecesInput.dispatchEvent(new Event('change'));
            pixelSizeSlider.dispatchEvent(new Event('input')); 
            unlockPieceSizeCheckbox.dispatchEvent(new Event('change'));

            console.log("All settings reset to defaults.");
        });

        randomizeButton.addEventListener('click', () => {
            // Randomize speed
            speedSlider.value = getRandomValue(parseFloat(speedSlider.min), parseFloat(speedSlider.max), parseFloat(speedSlider.step));
            speedSlider.dispatchEvent(new Event('input'));

            // Randomize pixel size
            pixelSizeSlider.value = getRandomValue(parseInt(pixelSizeSlider.min), parseInt(pixelSizeSlider.max), parseInt(pixelSizeSlider.step));
            pixelSizeSlider.dispatchEvent(new Event('input')); // This also triggers createPuzzlePiecesFromImage

            // Randomize gravity
            gravitySlider.value = getRandomValue(parseFloat(gravitySlider.min), parseFloat(gravitySlider.max), parseFloat(gravitySlider.step));
            gravitySlider.dispatchEvent(new Event('input'));

            // Randomize snap distance
            snapDistanceSlider.value = getRandomValue(parseFloat(snapDistanceSlider.min), parseFloat(snapDistanceSlider.max), parseFloat(snapDistanceSlider.step));
            snapDistanceSlider.dispatchEvent(new Event('input'));

            // Randomize repel
            repelSlider.value = getRandomValue(parseFloat(repelSlider.min), parseFloat(repelSlider.max), parseFloat(repelSlider.step));
            repelSlider.dispatchEvent(new Event('input'));

            // Randomize frequency
            frequencySlider.value = getRandomValue(parseFloat(frequencySlider.min), parseFloat(frequencySlider.max), parseFloat(frequencySlider.step));
            frequencySlider.dispatchEvent(new Event('input'));

            // No need to randomize max pieces or checkboxes for now, focus on sliders
            console.log("Sliders randomized!");
        });


        // App Versioning
        const APP_VERSION = 1.008;

        // Initialize on load
        window.onload = () => {
            if (initWebGL()) {
                // Set initial slider ranges based on default (unlocked is false)
                unlockFreedomCheckbox.checked = false; // Ensure it's initially unchecked
                unlockFreedomCheckbox.dispatchEvent(new Event('change')); // Trigger initial range setup

                // Set initial slider values and text based on constants
                animationSpeed = DEFAULT_SPEED_MIN; // Start with the actual min default speed
                speedSlider.value = animationSpeed;
                speedValueSpan.textContent = animationSpeed.toFixed(1);

                currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[DEFAULT_PIECE_SIZE_INDEX];
                pixelSizeSlider.value = DEFAULT_PIECE_SIZE_INDEX;
                lastSetPuzzlePieceSizeIndex = DEFAULT_PIECE_SIZE_INDEX; // Store initial value
                pixelSizeValueSpan.textContent = `${currentPuzzlePieceSize}x${currentPuzzlePieceSize}`;
                pixelSizeSlider.max = PUZZLE_PIECE_SIZES.length - 1; // Set max for piece size slider
                updatePieceSizeSliderRange(); // Update bounds for piece size slider

                gravityForce = DEFAULT_GRAVITY_MIN; // Start with the actual min default gravity
                gravitySlider.value = gravityForce;
                gravityValueSpan.textContent = gravityForce.toFixed(3); // Display with precision

                snapDistance = DEFAULT_SNAP_MIN;
                snapDistanceSlider.value = snapDistance;
                snapDistanceValueSpan.textContent = `${snapDistance} pixels`;
                
                repelForce = DEFAULT_REPEL_MIN;
                repelSlider.value = repelForce;
                repelValueSpan.textContent = repelForce.toFixed(2);

                repelFrequency = DEFAULT_FREQUENCY_MIN;
                frequencySlider.value = repelFrequency;
                frequencyValueSpan.textContent = repelFrequency.toString();


                maxPiecesInput.value = TARGET_MAX_PIECES;

                versionNumberSpan.textContent = `Version ${APP_VERSION.toFixed(3)}`;
                document.title = `Pixel Swirl Version ${APP_VERSION.toFixed(3)}`;

                lastRepelTriggerCheckTime = performance.now(); // Initialize repel timer
            }
        };

    </script>
</body>
</html>
