<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Swirl Version 1.005</title> <style>
        body {
            font-family: Arial, sans-serif;
            display: flex; /* Changed to flex to control main content better */
            flex-direction: row; /* Main content and right panel side-by-side */
            justify-content: flex-start; /* Align content to the start (left) */
            align-items: stretch; /* Stretch children to fill height */
            background-color: #222;
            color: #eee;
            margin: 0;
            padding: 0;
            height: 100vh; /* Make body fill viewport height */
            width: 100vw; /* Make body fill viewport width */
            overflow: hidden; /* Prevent scrollbars if content slightly overflows */
            box-sizing: border-box;
        }

        .main-content-container {
            display: flex;
            flex-direction: row; 
            flex-grow: 1; /* Allows it to take up available space */
            gap: 20px; /* Space between canvas and controls (if right-panel isn't fixed) */
            align-items: flex-start; /* Align content to the top */
            height: 100%; 
            padding: 10px; /* Small padding around the main content */
            box-sizing: border-box;
            /* Removed justify-content: center to avoid pushing canvas to center if right panel is fixed */
        }

        .canvas-container {
            flex-grow: 1; /* Allows it to take available space */
            flex-shrink: 1; /* Allows it to shrink if needed */
            max-width: 100%; /* Take full available width within main-content-container */
            max-height: calc(100vh - 20px); /* Limit canvas height based on viewport and main-container padding */
            display: flex; /* Use flex to center canvas if smaller than container */
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide any overflow if image is too big for its container */
        }

        canvas {
            border: 2px solid #555;
            background-color: #000;
            display: block;
            max-width: 100%; /* Scale canvas down to fit container */
            max-height: 100%; /* Scale canvas down to fit container */
            width: auto; /* Maintain aspect ratio */
            height: auto; /* Maintain aspect ratio */
            object-fit: contain; /* Ensures image fits within bounds without cropping */
        }

        .right-panel {
            display: flex;
            flex-direction: column; /* Stack controls and title vertically */
            gap: 8px; /* Reduced gap between each control "row" */
            padding: 10px; /* Small padding inside the right panel */
            min-width: 280px; /* Ensure enough space for controls */
            flex-shrink: 0; /* Prevent the right panel from shrinking too much */
            justify-content: flex-start; /* Align items to the top */
            height: 100%; /* Take full height of main-content-container */
            box-sizing: border-box;
            background-color: #333; /* Slightly darker background for controls */
            border-radius: 8px;

            /* Docking and Locking to the right */
            position: fixed; /* Make it fixed relative to the viewport */
            right: 0; /* Align to the very right edge */
            top: 0; /* Align to the very top edge */
            height: 100vh; /* Make it fill the full viewport height */
            z-index: 1000; /* Ensure it stays on top of other content */
            padding-right: 20px; /* Add some padding on the right side of the panel itself */
            padding-left: 10px; /* Adjust left padding as needed */
            box-shadow: -5px 0 10px rgba(0,0,0,0.3); /* Optional shadow for separation */
        }

        /* Adjust main content to not be hidden behind the fixed right panel */
        .main-content-container {
            margin-right: 310px; /* Width of right-panel + its right padding + gap/buffer */
            /* This pushes the main content to the left, leaving space for the fixed right panel */
        }


        .controls-row {
            display: flex;
            flex-direction: column; /* Force each control group to its own "row" */
            gap: 4px; /* Smaller gap within a control group */
            width: 100%; /* Take full width of right-panel */
        }

        .control-group {
            display: flex;
            flex-direction: column; /* Label above input/slider */
            align-items: flex-start;
            gap: 5px;
            white-space: nowrap; /* Prevent text labels from wrapping */
            width: 100%; /* Make control group fill its row */
        }

        /* Specific styling for horizontal alignment for slider + buttons */
        .slider-with-buttons {
            display: flex;
            flex-direction: row; /* Buttons and slider side-by-side */
            align-items: center;
            gap: 5px;
            width: 100%; /* Occupy full available width */
        }

        .slider-with-value { /* New class for slider with its value span */
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px; /* Space between slider and value */
            width: 100%;
        }

        input[type="range"] {
            flex-grow: 1; /* Allow slider to take up remaining space */
            min-width: 80px; /* Ensure it doesn't get too small */
        }
        input[type="number"] {
            width: 100%; /* Make number input fill its available width */
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #555;
            background-color: #333;
            color: #eee;
            font-size: 14px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            width: 100%; /* Make buttons full width in their "row" */
            box-sizing: border-box; /* Include padding and border in width */
        }
        button:hover {
            background-color: #0056b3;
        }
        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            border: 1px solid #ccc;
            display: inline-block;
            padding: 10px 20px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            width: 100%; /* Make load image button full width */
            box-sizing: border-box;
            text-align: center;
        }
        .custom-file-upload:hover {
            background-color: #218838;
        }
        .checkbox-group {
            display: flex;
            flex-direction: row; /* Checkbox and label side-by-side */
            align-items: center;
            gap: 8px; /* Space between checkbox and label */
            width: 100%;
        }
        .slider-button {
            padding: 5px 10px;
            font-size: 14px;
            min-width: 30px;
            width: auto; /* Override button width for these */
            flex-shrink: 0; /* Don't let buttons shrink */
        }

        .app-info {
            margin-top: auto; /* Push to the bottom of the right panel */
            text-align: left;
            width: 100%;
            padding-top: 15px; /* Add some space above title */
            border-top: 1px solid #555; /* Separator line */
            margin-top: 15px; /* Add space above separator */
        }
        .app-info h2 {
            margin-bottom: 5px; /* Space between title and version */
            margin-top: 0;
        }
        .app-info a {
            color: #8ab4f8; /* A nice blue for links */
            text-decoration: none;
        }
        .app-info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="main-content-container">
        <div class="canvas-container">
            <canvas id="pixelCanvas"></canvas>
        </div>
    </div>

    <div class="right-panel">
        <div class="controls-row">
            <div class="control-group">
                <label for="imageUpload" class="custom-file-upload">Load Image</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
        </div>

        <div class="controls-row">
            <button id="restartButton">Restart</button>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="maxPiecesInput">Max # of Pieces:</label>
                <input type="number" id="maxPiecesInput" value="100000" min="4" step="1"> </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="speedSlider">Piece Momentum:</label> <div class="slider-with-value">
                    <input type="range" id="speedSlider" min="0.1" max="5" value="1" step="0.1">
                    <span id="speedValue">1.0</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label>Puzzle Piece Size:</label>
                <div class="slider-with-buttons">
                    <button id="pixelSizeMinus" class="slider-button">-</button>
                    <input type="range" id="pixelSizeSlider" min="0" max="8" value="6" step="1">
                    <button id="pixelSizePlus" class="slider-button">+</button>
                </div>
                <span id="pixelSizeValue">64x64</span>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label for="gravitySlider">Gravity:</label>
                <div class="slider-with-value">
                    <input type="range" id="gravitySlider" min="0.01" max="0.5" value="0.05" step="0.01">
                    <span id="gravityValue">0.05</span>
                </div>
            </div>
        </div>
        
        <div class="controls-row">
            <div class="control-group">
                <label for="snapDistanceSlider">Snap Distance:</label>
                <div class="slider-with-value">
                    <input type="range" id="snapDistanceSlider" min="0" max="16" value="0" step="1">
                    <span id="snapDistanceValue">0 pixels</span>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="checkbox-group">
                <input type="checkbox" id="unlockFreedomCheckbox">
                <label for="unlockFreedomCheckbox">Unlock more freedom</label>
            </div>
        </div>

        <div class="controls-row">
            <div class="checkbox-group">
                <input type="checkbox" id="unlockPieceSizeCheckbox">
                <label for="unlockPieceSizeCheckbox">Unlock Piece Size (lag)</label>
            </div>
        </div>
        
        <div class="app-info">
            <h2>Pixel Swirl</h2>
            <span id="versionNumber">Version 1.005</span>
            <hr> <br>
            Check out other cool stuff:<br>
            <br>
            <a href="https://pirillo.com/arcade" target="_blank">https://pirillo.2025/arcade</a><br>
            <br>
            <a href="https://github.com/ChrisPirillo" target="_blank">https://github.com/ChrisPirillo</a>
            <hr> Vibe Coded with:<br>
            <a href="https://www.google.com/search?q=%22google+gemini%22" target="_blank">Gemini</a>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const imageUpload = document.getElementById('imageUpload');
        const restartButton = document.getElementById('restartButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue'); // New span for speed value
        const pixelSizeSlider = document.getElementById('pixelSizeSlider');
        const pixelSizeMinusBtn = document.getElementById('pixelSizeMinus');
        const pixelSizePlusBtn = document.getElementById('pixelSizePlus');
        const pixelSizeValueSpan = document.getElementById('pixelSizeValue');
        const gravitySlider = document.getElementById('gravitySlider');
        const gravityValueSpan = document.getElementById('gravityValue');
        const snapDistanceSlider = document.getElementById('snapDistanceSlider');
        const snapDistanceValueSpan = document.getElementById('snapDistanceValue');
        const unlockPieceSizeCheckbox = document.getElementById('unlockPieceSizeCheckbox');
        const unlockFreedomCheckbox = document.getElementById('unlockFreedomCheckbox'); // New freedom checkbox
        const versionNumberSpan = document.getElementById('versionNumber');
        const maxPiecesInput = document.getElementById('maxPiecesInput');

        // Added more granular small sizes
        const PUZZLE_PIECE_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 16, 32, 64, 128, 256, 512];
        
        // This will be read from the input box, default value used for initial setup
        let TARGET_MAX_PIECES = 100000; 

        // Default ranges for sliders (before unlock freedom)
        const DEFAULT_SPEED_MAX = 5;
        const DEFAULT_GRAVITY_MIN = 0.01;
        const DEFAULT_GRAVITY_MAX = 0.5;
        const DEFAULT_SNAP_MAX = 16;

        // Unlocked ranges for sliders
        const UNLOCKED_SPEED_MAX = 10;
        const UNLOCKED_GRAVITY_MIN = 0.001;
        const UNLOCKED_GRAVITY_MAX = 0.99;
        const UNLOCKED_SNAP_MAX = 256;


        let gl = null;
        let program = null;
        let positionBuffer = null;
        let texCoordBuffer = null;
        let numVertices = 0; // Total vertices for all quads (6 per quad)
        let animationFrameId = null;
        let originalImageObject = null;

        let currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[10]; // Initial 64x64 (updated index for new array)
        let animationSpeed = 1;
        let gravityForce = 0.05;
        let snapDistance = 0;

        let puzzlePieces = [];
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        let currentMinPieceSizeIndex = 0; // Index in PUZZLE_PIECE_SIZES array

        let mainAtlasTexture = null; // The single texture atlas for all pieces
        let allPositions = null;     // Float32Array to hold all current piece positions
        let allTexCoords = null;     // Float32Array to hold all texture coordinates within the atlas (fixed)

        // --- Shaders ---
        const vsSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            uniform mat4 u_projectionMatrix;

            void main() {
                gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec2 v_texCoord;
            uniform sampler2D u_sampler;

            void main() {
                gl_FragColor = texture2D(u_sampler, v_texCoord);
            }
        `;

        // --- WebGL Initialization ---
        function initWebGL() {
            gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('Unable to initialize WebGL. Your browser or machine may not support it.');
                alert('WebGL is not supported in your browser. This simulator requires WebGL.');
                return false;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Standard alpha blending

            program = initShaderProgram(gl, vsSource, fsSource);
            if (!program) return false;

            gl.useProgram(program);

            positionBuffer = gl.createBuffer();
            texCoordBuffer = gl.createBuffer();

            return true;
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                console.error('Vertex Shader Info:', gl.getShaderInfoLog(vertexShader));
                console.error('Fragment Shader Info:', gl.getShaderInfoLog(fragmentShader));
                gl.deleteProgram(shaderProgram);
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProjectionMatrix(width, height) {
            return new Float32Array([
                2 / width, 0, 0, 0,
                0, -2 / height, 0, 0,
                0, 0, 1, 0,
                -1, 1, 0, 1
            ]);
        }

        // --- Core Logic for Particles (Puzzle Pieces) ---
        class PuzzlePiece {
            // Now stores texture UV coordinates for its part of the atlas
            constructor(startX, startY, targetX, targetY, pieceDimension, texU0, texV0, texU1, texV1) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.dimension = pieceDimension;
                this.texCoords = [
                    texU0, texV0, // Top-Left
                    texU1, texV0, // Top-Right
                    texU0, texV1, // Bottom-Left

                    texU0, texV1, // Bottom-Left
                    texU1, texV0, // Top-Right
                    texU1, texV1  // Bottom-Right
                ]; // Stored once per piece, relative to atlas

                this.vx = 0;
                this.vy = 0;
                this.settled = false;
                this.maxSpeed = 10 * animationSpeed;
                this.attractionForce = gravityForce * animationSpeed;
                this.damping = 0.95;
                this.swirlRadius = Math.random() * 200 + 50;
                this.swirlAngle = Math.random() * Math.PI * 2;
                this.swirlSpeed = Math.random() * 0.05 + 0.01;
            }

            update() {
                if (this.settled) {
                    return;
                }

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const normalizedDistance = Math.min(1, distance / 5.0 / (this.swirlRadius > 0 ? this.swirlRadius : 1));
                const swirlDampingFactor = 0.99 - (gravityForce * 0.7 * (1 - normalizedDistance));
                this.swirlRadius *= Math.max(0.7, swirlDampingFactor);

                if (distance <= snapDistance + 0.01) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.vx = 0;
                    this.vy = 0;
                    this.settled = true;
                    this.swirlRadius = 0;
                    return;
                }

                this.swirlAngle += this.swirlSpeed * animationSpeed;
                // Corrected: Define swirlOffsetX and swirlOffsetY locally
                const swirlOffsetX = this.swirlRadius * Math.cos(this.swirlAngle);
                const swirlOffsetY = this.swirlRadius * Math.sin(this.swirlAngle);

                // Corrected: Define swirlTargetX and swirlTargetY locally
                const swirlTargetX = this.targetX + swirlOffsetX;
                const swirlTargetY = this.targetY + swirlOffsetY;

                const swirlDx = swirlTargetX - this.x;
                const swirlDy = swirlTargetY - this.y;

                this.vx += swirlDx * this.attractionForce;
                this.vy += swirlDy * this.attractionForce;

                this.vx *= this.damping;
                this.vy *= this.damping;

                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > this.maxSpeed) {
                    const scale = this.maxSpeed / currentSpeed;
                    this.vx *= scale;
                    this.vy *= scale;
                }

                this.x += this.vx;
                this.y += this.vy;
                
                if (distance < 1 && this.swirlRadius < 5 && Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.settled = true;
                    this.vx = 0;
                    this.vy = 0;
                    this.swirlRadius = 0;
                }
            }
        }

        // Helper to find next power of 2
        function nextPowerOf2(n) {
            if (n === 0) return 1;
            n--;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            n++;
            return n;
        }

        // --- Setup and Rendering ---

        function resizeCanvasToImage(img) {
            // Set canvas dimensions to image dimensions, then let CSS handle scaling
            canvas.width = img.width;
            canvas.height = img.height;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            const projectionMatrix = createProjectionMatrix(gl.canvas.width, gl.canvas.height);
            const uProjectionMatrixLoc = gl.getUniformLocation(program, 'u_projectionMatrix');
            gl.uniformMatrix4fv(uProjectionMatrixLoc, false, projectionMatrix);
        }

        function calculateMinPieceSizeForImage() {
            if (!originalImageObject) return;

            const imgWidth = originalImageObject.width;
            const imgHeight = originalImageObject.height;
            
            let calculatedMinIndex = 0; // Default to 1x1 (index 0)

            // Read the current TARGET_MAX_PIECES from the input box
            const currentTargetMaxPieces = parseInt(maxPiecesInput.value);

            // Iterate through PUZZLE_PIECE_SIZES to find the smallest piece dimension (P)
            // that results in a total piece count <= currentTargetMaxPieces.
            for (let i = 0; i < PUZZLE_PIECE_SIZES.length; i++) {
                const p = PUZZLE_PIECE_SIZES[i];
                // Correct piece count calculation: divide width by P, height by P, then multiply
                const pieceCountX = Math.ceil(imgWidth / p);
                const pieceCountY = Math.ceil(imgHeight / p);
                const totalPieceCount = pieceCountX * pieceCountY;

                if (totalPieceCount <= currentTargetMaxPieces) {
                    calculatedMinIndex = i; // This 'p' is a valid minimum.
                                            // Since we iterate from smallest to largest piece size,
                                            // the first one we find that fits is the ideal minimum.
                    break; 
                }
            }
            currentMinPieceSizeIndex = calculatedMinIndex;
            updatePieceSizeSliderRange();
        }

        function updatePieceSizeSliderRange() {
            if (unlockPieceSizeCheckbox.checked) {
                pixelSizeSlider.min = 0; // Allow 1x1 pieces
            } else {
                pixelSizeSlider.min = currentMinPieceSizeIndex;
            }

            // Ensure slider value is not below the new minimum or above max
            let sliderVal = parseInt(pixelSizeSlider.value);
            const sliderMin = parseInt(pixelSizeSlider.min);
            const sliderMax = parseInt(pixelSizeSlider.max);

            let valueChanged = false;
            if (sliderVal < sliderMin) {
                pixelSizeSlider.value = sliderMin;
                valueChanged = true;
            } else if (sliderVal > sliderMax) {
                // If the slider value is currently greater than the max (e.g., max was lowered)
                pixelSizeSlider.value = sliderMax;
                valueChanged = true;
            }
            
            if (valueChanged) {
                // If the value changed, trigger the input event manually
                pixelSizeSlider.dispatchEvent(new Event('input'));
            } else {
                // Otherwise, just update the display and button states
                pixelSizeValueSpan.textContent = `${PUZZLE_PIECE_SIZES[pixelSizeSlider.value]}x${PUZZLE_PIECE_SIZES[pixelSizeSlider.value]}`;
                pixelSizeMinusBtn.disabled = parseInt(pixelSizeSlider.value) <= parseInt(pixelSizeSlider.min);
                pixelSizePlusBtn.disabled = parseInt(pixelSizeSlider.value) >= parseInt(pixelSizeSlider.max);
            }
        }


        function createPuzzlePiecesFromImage() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Update TARGET_MAX_PIECES from the input box before creating pieces
            let inputValue = parseInt(maxPiecesInput.value);
            // Input validation: ensure it's at least 4 and truncate decimals
            if (isNaN(inputValue) || inputValue < 4) {
                inputValue = 4;
                maxPiecesInput.value = 4;
            } else {
                maxPiecesInput.value = Math.floor(inputValue); // Truncate decimals
            }
            TARGET_MAX_PIECES = inputValue;

            // Clean up old main texture if it exists
            if (mainAtlasTexture) {
                gl.deleteTexture(mainAtlasTexture);
                mainAtlasTexture = null;
            }

            puzzlePieces = [];
            numVertices = 0;
            // allPositions and allTexCoords will be initialized after counting pieces

            const imgWidth = originalImageObject.width;
            const imgHeight = originalImageObject.height;
            const pieceDim = currentPuzzlePieceSize;

            // Calculate the number of pieces in columns and rows
            const numPiecesX = Math.ceil(imgWidth / pieceDim);
            const numPiecesY = Math.ceil(imgHeight / pieceDim);

            // Determine dimensions for the texture atlas
            // Each piece will occupy `pieceDim` x `pieceDim` space in the atlas
            const atlasWidth = nextPowerOf2(numPiecesX * pieceDim);
            const atlasHeight = nextPowerOf2(numPiecesY * pieceDim);

            const atlasCanvas = document.createElement('canvas');
            const atlasCtx = atlasCanvas.getContext('2d', { willReadFrequently: true });
            atlasCanvas.width = atlasWidth;
            atlasCanvas.height = atlasHeight;
            atlasCtx.clearRect(0, 0, atlasWidth, atlasHeight); // Clear the atlas canvas

            let pieceCount = 0;

            for (let y = 0; y < imgHeight; y += pieceDim) {
                for (let x = 0; x < imgWidth; x += pieceDim) {
                    const currentPieceSrcX = x; // Source X coord in original image
                    const currentPieceSrcY = y; // Source Y coord in original image
                    
                    // Calculate position of this piece within the atlas
                    const atlasCol = Math.floor(currentPieceSrcX / pieceDim);
                    const atlasRow = Math.floor(currentPieceSrcY / pieceDim);

                    const atlasDestX = atlasCol * pieceDim;
                    const atlasDestY = atlasRow * pieceDim;

                    // Draw a segment of the original image onto the atlas canvas
                    atlasCtx.drawImage(
                        originalImageObject,
                        currentPieceSrcX, currentPieceSrcY, pieceDim, pieceDim, // Source rectangle
                        atlasDestX, atlasDestY, pieceDim, pieceDim              // Destination rectangle on atlas
                    );
                    
                    // Transparency logic removed as per request. All pieces assumed opaque.
                    // No check for `hasVisiblePixels` needed here, always add the piece.

                    // Calculate normalized texture coordinates for this piece within the atlas
                    // These are the UVs that the shader will use to sample from mainAtlasTexture
                    const texU0 = atlasDestX / atlasWidth;
                    const texV0 = atlasDestY / atlasHeight;
                    const texU1 = (atlasDestX + pieceDim) / atlasWidth;
                    const texV1 = (atlasDestY + pieceDim) / atlasHeight;

                    // Random starting position for the piece outside the canvas
                    let startX, startY;
                    const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left

                    if (edge === 0) { // Top
                        startX = Math.random() * imgWidth;
                        startY = -Math.random() * 200;
                    } else if (edge === 1) { // Right
                        startX = imgWidth + Math.random() * 200;
                        startY = Math.random() * imgHeight;
                    } else if (edge === 2) { // Bottom
                        startX = Math.random() * imgWidth;
                        startY = imgHeight + Math.random() * 200;
                    } else { // Left
                        startX = -Math.random() * 200;
                        startY = Math.random() * imgHeight;
                    }
                    
                    puzzlePieces.push(new PuzzlePiece(startX, startY, x, y, pieceDim, texU0, texV0, texU1, texV1));
                    numVertices += 6; // Each piece is 2 triangles (1 quad) = 6 vertices
                    pieceCount++;
                }
            }

            // Create the single main texture atlas
            mainAtlasTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, mainAtlasTexture);

            // Upload the entire atlas canvas to the GPU as one texture
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
            
            // Set texture parameters for atlas (important for non-power-of-two, if not using nextPowerOf2)
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // LINEAR for smoother scaling
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            // Initialize allPositions and allTexCoords to correct size
            allPositions = new Float32Array(numVertices * 2); // 2 components (x, y) per vertex
            allTexCoords = new Float32Array(numVertices * 2); // 2 components (u, v) per vertex

            // Populate allTexCoords once (they don't change per frame)
            let texCoordIndex = 0;
            puzzlePieces.forEach(piece => {
                for (let i = 0; i < piece.texCoords.length; i++) {
                    allTexCoords[texCoordIndex++] = piece.texCoords[i];
                }
            });

            // Allocate and upload static texture coordinates once to the GPU.
            // STATIC_DRAW indicates data won't change often.
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, allTexCoords, gl.STATIC_DRAW); // Allocate buffer with data

            // Allocate the position buffer on the GPU. Its contents will be updated every frame.
            // DYNAMIC_DRAW hints to WebGL that data will be changed frequently.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, allPositions.byteLength, gl.DYNAMIC_DRAW); // Allocate space only

            console.log(`Created ${pieceCount} puzzle pieces (Total GL vertices: ${numVertices}) with dimension ${pieceDim}x${pieceDim}. Gravity: ${gravityForce}, Snap Distance: ${snapDistance}. Atlas size: ${atlasWidth}x${atlasHeight}`);
            
            startAnimation();
        }

        function drawScene() {
            gl.clear(gl.COLOR_BUFFER_BIT);

            let currentPositionIndex = 0;
            let allSettled = true;

            // Update piece positions and fill the allPositions array for this frame
            puzzlePieces.forEach(piece => {
                if (!piece.settled) {
                    piece.update();
                    allSettled = false;
                }

                const x0 = piece.x;
                const y0 = piece.y;
                const x1 = piece.x + piece.dimension;
                const y1 = piece.y + piece.dimension;

                // Positions for the 2 triangles forming the quad (6 vertices total)
                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y0; // Top-Left
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y0; // Top-Right
                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y1; // Bottom-Left

                allPositions[currentPositionIndex++] = x0; allPositions[currentPositionIndex++] = y1; // Bottom-Left
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y0; // Top-Right
                allPositions[currentPositionIndex++] = x1; allPositions[currentPositionIndex++] = y1; // Bottom-Right
            });

            const aPositionLoc = gl.getAttribLocation(program, 'a_position');
            const aTexCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
            const uSamplerLoc = gl.getUniformLocation(program, 'u_sampler');

            // --- Single Draw Call Optimization ---
            // 1. Bind the main atlas texture once for the entire frame
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, mainAtlasTexture);
            gl.uniform1i(uSamplerLoc, 0); // Tell the shader to use texture unit 0

            // 2. Upload all updated positions to the GPU (DYNAMIC_DRAW as they change every frame)
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, allPositions); // Use bufferSubData to update existing buffer

            // 3. Set up position attribute pointer
            gl.enableVertexAttribArray(aPositionLoc);
            gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

            // 4. Set up texture coordinate attribute pointer (already uploaded as STATIC_DRAW)
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); // Re-bind texCoordBuffer just in case
            gl.enableVertexAttribArray(aTexCoordLoc);
            gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, 0);

            // 5. Draw all pieces in one call!
            gl.drawArrays(gl.TRIANGLES, 0, numVertices);

            if (!allSettled) {
                animationFrameId = requestAnimationFrame(drawScene);
            } else {
                console.log("All puzzle pieces settled.");
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (puzzlePieces.length > 0) {
                puzzlePieces.forEach(p => {
                    p.settled = false;
                    p.swirlRadius = Math.random() * 200 + 50;
                    p.swirlAngle = Math.random() * Math.PI * 2;
                    p.swirlSpeed = Math.random() * 0.05 + 0.01;
                    p.vx = 0; // Reset velocities
                    p.vy = 0;
                });
                drawScene();
            }
        }

        // --- Event Listeners ---

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImageObject = img;
                        resizeCanvasToImage(img);
                        // Recalculate min piece size based on the new image and current TARGET_MAX_PIECES
                        calculateMinPieceSizeForImage(); 

                        // After calculating the new min piece size, set the slider to this new min
                        // and trigger its input event to update currentPuzzlePieceSize
                        pixelSizeSlider.value = currentMinPieceSizeIndex;
                        pixelSizeSlider.dispatchEvent(new Event('input')); // This will call createPuzzlePiecesFromImage()

                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        restartButton.addEventListener('click', () => {
            if (originalImageObject) {
                // When restart is clicked, first update the global TARGET_MAX_PIECES
                // from the input box, then recalculate min piece size.
                let inputValue = parseInt(maxPiecesInput.value);
                if (isNaN(inputValue) || inputValue < 4) {
                    inputValue = 4;
                    maxPiecesInput.value = 4;
                } else {
                    maxPiecesInput.value = Math.floor(inputValue);
                }
                TARGET_MAX_PIECES = inputValue;
                
                calculateMinPieceSizeForImage(); 
                
                // Crucial fix: after recalculating the new minimum piece size
                // (currentMinPieceSizeIndex), set the slider to this new minimum
                // so that the image restarts with the correct piece size based on the new max pieces.
                pixelSizeSlider.value = currentMinPieceSizeIndex;
                pixelSizeSlider.dispatchEvent(new Event('input')); // This will trigger createPuzzlePiecesFromImage()
            } else {
                alert("Please load an image first!");
            }
        });

        speedSlider.addEventListener('input', (event) => {
            animationSpeed = parseFloat(event.target.value);
            speedValueSpan.textContent = animationSpeed.toFixed(1); // Update speed value display
            puzzlePieces.forEach(p => {
                p.maxSpeed = 10 * animationSpeed; // Note: 10 here is tied to animationSpeed, not a global variable.
                p.attractionForce = gravityForce * animationSpeed;
            });
            if (animationFrameId === null && originalImageObject) {
                 startAnimation(); // Restart animation if it was settled
            }
        });

        pixelSizeSlider.addEventListener('input', (event) => {
            const sliderIndex = parseInt(event.target.value);
            currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[sliderIndex];
            pixelSizeValueSpan.textContent = `${currentPuzzlePieceSize}x${currentPuzzlePieceSize}`;
            if (originalImageObject) {
                createPuzzlePiecesFromImage(); 
            }
            updatePieceSizeSliderRange(); // Update button states based on new slider value
        });

        pixelSizeMinusBtn.addEventListener('click', () => {
            const currentValue = parseInt(pixelSizeSlider.value);
            const minValue = parseInt(pixelSizeSlider.min);
            if (currentValue > minValue) {
                pixelSizeSlider.value = currentValue - 1;
                pixelSizeSlider.dispatchEvent(new Event('input')); // Trigger input event to update everything
            }
        });

        pixelSizePlusBtn.addEventListener('click', () => {
            const currentValue = parseInt(pixelSizeSlider.value);
            const maxValue = parseInt(pixelSizeSlider.max);
            if (currentValue < maxValue) {
                pixelSizeSlider.value = currentValue + 1;
                pixelSizeSlider.dispatchEvent(new Event('input')); // Trigger input event to update everything
            }
        });

        gravitySlider.addEventListener('input', (event) => {
            gravityForce = parseFloat(event.target.value);
            gravityValueSpan.textContent = gravityForce.toFixed(gravityForce < 0.01 ? 3 : 2); // Show more decimals for small values
            puzzlePieces.forEach(p => {
                p.attractionForce = gravityForce * animationSpeed;
            });
            if (animationFrameId === null && originalImageObject) {
                 startAnimation(); // Restart animation if it was settled
            }
        });

        snapDistanceSlider.addEventListener('input', (event) => {
            snapDistance = parseFloat(event.target.value);
            snapDistanceValueSpan.textContent = `${snapDistance} pixels`;
        });

        unlockPieceSizeCheckbox.addEventListener('change', () => {
            updatePieceSizeSliderRange(); // Adjust slider min based on unlock status
        });

        unlockFreedomCheckbox.addEventListener('change', (event) => {
            if (event.target.checked) {
                speedSlider.max = UNLOCKED_SPEED_MAX;
                gravitySlider.min = UNLOCKED_GRAVITY_MIN;
                gravitySlider.max = UNLOCKED_GRAVITY_MAX;
                snapDistanceSlider.max = UNLOCKED_SNAP_MAX;
            } else {
                speedSlider.max = DEFAULT_SPEED_MAX;
                gravitySlider.min = DEFAULT_GRAVITY_MIN;
                gravitySlider.max = DEFAULT_GRAVITY_MAX;
                snapDistanceSlider.max = DEFAULT_SNAP_MAX;
            }
            // Ensure values are within new bounds and update display
            speedSlider.value = Math.min(parseFloat(speedSlider.value), parseFloat(speedSlider.max));
            speedSlider.value = Math.max(parseFloat(speedSlider.value), parseFloat(speedSlider.min));
            speedSlider.dispatchEvent(new Event('input')); // Trigger to update UI and values
            
            gravitySlider.value = Math.min(parseFloat(gravitySlider.value), parseFloat(gravitySlider.max));
            gravitySlider.value = Math.max(parseFloat(gravitySlider.value), parseFloat(gravitySlider.min));
            gravitySlider.dispatchEvent(new Event('input'));

            snapDistanceSlider.value = Math.min(parseFloat(snapDistanceSlider.value), parseFloat(snapDistanceSlider.max));
            snapDistanceSlider.value = Math.max(parseFloat(snapDistanceSlider.value), parseFloat(snapDistanceSlider.min));
            snapDistanceSlider.dispatchEvent(new Event('input'));
        });


        // Max Pieces Input validation on blur (when user clicks out or tabs away)
        maxPiecesInput.addEventListener('change', () => {
            let inputValue = parseInt(maxPiecesInput.value);
            if (isNaN(inputValue) || inputValue < 4) {
                maxPiecesInput.value = 4;
            } else {
                maxPiecesInput.value = Math.floor(inputValue); // Truncate decimals
            }
            // TARGET_MAX_PIECES will be updated on Restart button click
            console.log("Max # of Pieces changed to:", maxPiecesInput.value, "Will apply on Restart.");
        });


        // App Versioning
        const APP_VERSION = 1.005;

        // Initialize on load
        window.onload = () => {
            if (initWebGL()) {
                // Set initial slider values and text
                currentPuzzlePieceSize = 64; // Set desired starting size
                pixelSizeSlider.value = PUZZLE_PIECE_SIZES.indexOf(currentPuzzlePieceSize);
                if (pixelSizeSlider.value === -1) { 
                    pixelSizeSlider.value = 0; // Default to 1x1 if 64 is somehow not found
                    currentPuzzlePieceSize = PUZZLE_PIECE_SIZES[0];
                }

                pixelSizeValueSpan.textContent = `${currentPuzzlePieceSize}x${currentPuzzlePieceSize}`;
                
                // Initialize default slider ranges
                speedSlider.max = DEFAULT_SPEED_MAX;
                gravitySlider.min = DEFAULT_GRAVITY_MIN;
                gravitySlider.max = DEFAULT_GRAVITY_MAX;
                snapDistanceSlider.max = DEFAULT_SNAP_MAX;

                speedSlider.value = animationSpeed;
                speedValueSpan.textContent = animationSpeed.toFixed(1);

                gravitySlider.value = gravityForce;
                gravityValueSpan.textContent = gravityForce.toFixed(2);
                snapDistanceSlider.value = snapDistance;
                snapDistanceValueSpan.textContent = `${snapDistance} pixels`;

                maxPiecesInput.value = TARGET_MAX_PIECES; // Set initial value of the input box

                // Initial setup for the piece size slider range and buttons
                pixelSizeSlider.max = PUZZLE_PIECE_SIZES.length - 1; // Set max based on array length
                updatePieceSizeSliderRange(); // Call this to set initial min and button states

                // Set initial version number and update titlebar
                versionNumberSpan.textContent = `Version ${APP_VERSION.toFixed(3)}`;
                document.title = `Pixel Swirl Version ${APP_VERSION.toFixed(3)}`;
            }
        };

    </script>
</body>
</html>
