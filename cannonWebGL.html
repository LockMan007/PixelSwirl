<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cannon Game (WebGL)</title>
    <style>
        /* Basic reset and font */
        body {
            margin: 0;
            padding: 0;
            font-family: "Inter", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f0f4f8; /* Light background for the page */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent body scroll bars */
            color: #333;
        }

        /* Main container for the game and controls */
        .game-container {
            position: relative;
            width: 95%; /* Responsive width */
            max-width: 900px; /* Max width for larger screens */
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 20px;
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Default to column for small screens */
            align-items: center;
            gap: 20px; /* Space between canvas and controls */
        }

        @media (min-width: 768px) { /* For larger screens, arrange side-by-side */
            .game-container {
                flex-direction: row;
                justify-content: center;
                align-items: flex-start; /* Align items to the top */
            }
        }

        h1 {
            font-size: 2.25rem; /* 36px */
            font-weight: 700; /* bold */
            margin-bottom: 1.5rem; /* 24px */
            color: #2d3748; /* gray-800 */
        }

        canvas {
            background-color: transparent; /* Background will be drawn by JS */
            display: block;
            border-radius: 10px; /* Rounded corners for the canvas */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for canvas */
            width: 100%; /* Make canvas fill its container width */
            max-width: 600px; /* Max width for canvas */
            aspect-ratio: 1 / 1; /* Maintain 1:1 aspect ratio */
        }

        @media (min-width: 768px) {
            canvas {
                width: calc(100% - 250px); /* Adjust width to make space for settings */
            }
        }

        /* Message box for audio prompt */
        #messageBox {
            position: absolute;
            inset: 0; /* Cover the entire parent */
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            z-index: 10; /* Ensure it's on top */
            text-align: center;
        }

        #messageBox p {
            color: #ffffff;
            font-size: 1.25rem; /* 20px */
            font-weight: 600; /* semibold */
            padding: 1rem; /* 16px */
            border-radius: 6px;
            background-color: #4a5568; /* gray-700 */
        }

        /* Settings controls */
        .settings-container {
            width: 100%;
            max-width: 220px; /* Max width for settings column */
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-top: 10px;
            padding-left: 10px; /* Add some padding if next to canvas */
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 100%;
        }

        .setting-item label {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-item input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* Remove default slider styles */
            height: 8px;
            background: #d1d5db; /* light gray */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .setting-item input[type="range"]:hover {
            opacity: 1;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .setting-item span {
            font-size: 0.9rem;
            color: #6b7280; /* gray-500 */
            margin-top: 5px;
        }

        .setting-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4f46e5; /* indigo-600 */
        }

        .action-button {
            background-color: #ef4444; /* Red color for delete */
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            width: 100%;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .action-button:hover {
            background-color: #dc2626; /* Darker red on hover */
        }
    </style>
</head>
<body>
    <h1>Cannon Game (WebGL)</h1>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="messageBox" style="display: none;">
            <p>Please click anywhere to start the game and enable sound!</p>
        </div>

        <div class="settings-container">
            <div class="setting-item">
                <label for="muteAudioToggle">
                    <input type="checkbox" id="muteAudioToggle">
                    Mute Audio
                </label>
            </div>
            <div class="setting-item">
                <label for="shotPowerSlider">Shot Power:</label>
                <input type="range" id="shotPowerSlider" min="1" max="20" value="6.5" step="0.5">
                <span id="shotPowerValue">6.5</span>
            </div>
            <div class="setting-item">
                <label for="fireRateSlider">Fire Rate:</label>
                <input type="range" id="fireRateSlider" min="100" max="2000" value="200" step="100">
                <span id="fireRateValue">0.2 sec</span>
            </div>
            <div class="setting-item">
                <label for="gravitySlider">Gravity:</label>
                <input type="range" id="gravitySlider" min="0.01" max="0.2" value="0.05" step="0.01">
                <span id="gravityValue">0.05</span>
            </div>
            <div class="setting-item">
                <label for="mortarToggle">
                    <input type="checkbox" id="mortarToggle" checked>
                    Mortars
                </label>
            </div>
            <div class="setting-item">
                <label for="bombToggle">
                    <input type="checkbox" id="bombToggle">
                    Bombs
                </label>
            </div>
            <div class="setting-item">
                <label for="darkModeToggle">
                    <input type="checkbox" id="darkModeToggle">
                    Dark Mode
                </label>
            </div>
            <button id="restartBtn" class="action-button">Restart</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        let gl = canvas.getContext("webgl"); // Get WebGL context
        const messageBox = document.getElementById("messageBox");

        // Settings elements
        const muteAudioToggle = document.getElementById("muteAudioToggle");
        const shotPowerSlider = document.getElementById("shotPowerSlider");
        const shotPowerValueSpan = document.getElementById("shotPowerValue");
        const fireRateSlider = document.getElementById("fireRateSlider");
        const fireRateValueSpan = document.getElementById("fireRateValue");
        const gravitySlider = document.getElementById("gravitySlider");
        const gravityValueSpan = document.getElementById("gravityValue");
        const mortarToggle = document.getElementById("mortarToggle");
        const bombToggle = document.getElementById("bombToggle");
        const darkModeToggle = document.getElementById("darkModeToggle");
        const restartBtn = document.getElementById("restartBtn");

        // Game State Variables
        let mousePos = null;
        let angle = null;
        let canShoot = true;
        let shotPower = parseFloat(shotPowerSlider.value);
        let gravityValue = parseFloat(gravitySlider.value);
        let fireRateDelay = parseInt(fireRateSlider.value); // Milliseconds
        let isMuted = muteAudioToggle.checked;
        let isMortarMode = mortarToggle.checked;
        let isBombMode = bombToggle.checked;
        let isDarkMode = darkModeToggle.checked;

        // Cannon movement
        let cannonMoveSpeed = 5; // Pixels per frame
        let keysPressed = {}; // To track multiple key presses

        // Arrays for game objects
        let cannonBalls = [];
        let explosionPieces = [];

        // --- Performance Optimization ---
        const MAX_EXPLOSION_PIECES = 500; // Limit the total number of explosion pieces

        // --- Web Audio API for Sound Effects ---
        let audioContext;
        let cannonOscillator;
        let cannonGain;
        let collisionOscillator1, collisionOscillator2;
        let collisionGain;
        let explosionOscillator;
        let explosionGain;
        let sizzleNoiseBuffer; // For bomb fuse sizzle (reusable buffer)
        let sizzleFilter;
        let sizzleGain;
        let sizzleBufferSource = null; // To control start/stop of sizzle

        /**
         * Initializes the Web Audio API context and nodes.
         * This must be called after a user gesture.
         */
        function initializeAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Cannon Sound (low tone beep)
                cannonOscillator = audioContext.createOscillator();
                cannonOscillator.type = 'sine';
                cannonOscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                cannonOscillator.start();

                cannonGain = audioContext.createGain();
                cannonGain.gain.setValueAtTime(0, audioContext.currentTime);
                cannonOscillator.connect(cannonGain);
                cannonGain.connect(audioContext.destination);

                // Collision Sound (metallic percussive)
                collisionOscillator1 = audioContext.createOscillator();
                collisionOscillator1.type = 'triangle';
                collisionOscillator1.frequency.setValueAtTime(200, audioContext.currentTime);
                collisionOscillator1.start();

                collisionOscillator2 = audioContext.createOscillator();
                collisionOscillator2.type = 'square';
                collisionOscillator2.frequency.setValueAtTime(400, audioContext.currentTime);
                collisionOscillator2.start();

                collisionGain = audioContext.createGain();
                collisionGain.gain.setValueAtTime(0, audioContext.currentTime);
                collisionOscillator1.connect(collisionGain);
                collisionOscillator2.connect(collisionGain);
                collisionGain.connect(audioContext.destination);

                // Explosion Sound (short, noisy burst)
                explosionOscillator = audioContext.createOscillator();
                explosionOscillator.type = 'sawtooth';
                explosionOscillator.frequency.setValueAtTime(60, audioContext.currentTime);
                explosionOscillator.start();

                explosionGain = audioContext.createGain();
                explosionGain.gain.setValueAtTime(0, audioContext.currentTime);
                explosionOscillator.connect(explosionGain);
                explosionGain.connect(audioContext.destination);

                // Sizzling Fuse Sound (white noise through bandpass filter)
                // Create a reusable noise buffer
                const bufferSize = audioContext.sampleRate * 0.5; // 0.5 seconds of noise
                sizzleNoiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = sizzleNoiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }

                sizzleFilter = audioContext.createBiquadFilter();
                sizzleFilter.type = 'bandpass';
                sizzleFilter.frequency.setValueAtTime(8000, audioContext.currentTime);
                sizzleFilter.Q.setValueAtTime(1, audioContext.currentTime);

                sizzleGain = audioContext.createGain();
                sizzleGain.gain.setValueAtTime(0, audioContext.currentTime);
                sizzleGain.connect(audioContext.destination);

                isAudioInitialized = true;
                messageBox.style.display = 'none'; // Hide message box
            }
        }

        /**
         * Plays the cannon firing sound.
         */
        function playCannonSound() {
            if (!isAudioInitialized || isMuted) return;

            const now = audioContext.currentTime;
            cannonGain.gain.cancelScheduledValues(now);
            cannonGain.gain.setValueAtTime(0.5, now);
            cannonGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        }

        /**
         * Plays the collision sound.
         */
        function playCollisionSound() {
            if (!isAudioInitialized || isMuted) return;

            const now = audioContext.currentTime;
            collisionGain.gain.cancelScheduledValues(now);
            collisionGain.gain.setValueAtTime(0.3, now);
            collisionGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        }

        /**
         * Plays the explosion sound.
         */
        function playExplosionSound() {
            if (!isAudioInitialized || isMuted) return;

            const now = audioContext.currentTime;
            explosionGain.gain.cancelScheduledValues(now);
            explosionGain.gain.setValueAtTime(0.8, now); // Louder for explosion
            explosionGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5); // Slightly longer decay
        }

        /**
         * Starts the sizzling fuse sound for a bomb.
         * @param {number} duration - The duration over which the sizzle should fade out.
         */
        function startSizzleSound(duration) {
            if (!isAudioInitialized || isMuted) return;

            // Stop any existing sizzle sound before starting a new one
            if (sizzleBufferSource) {
                try {
                    sizzleBufferSource.stop();
                    sizzleBufferSource.disconnect();
                } catch (e) {
                    // Already stopped or disconnected
                }
            }

            sizzleBufferSource = audioContext.createBufferSource();
            sizzleBufferSource.buffer = sizzleNoiseBuffer; // Use the pre-generated buffer
            sizzleBufferSource.loop = true;
            sizzleBufferSource.connect(sizzleFilter);
            sizzleFilter.connect(sizzleGain); // Connect filter to gain
            sizzleBufferSource.start();

            const now = audioContext.currentTime;
            sizzleGain.gain.cancelScheduledValues(now);
            sizzleGain.gain.setValueAtTime(0.4, now); // Start loud
            sizzleGain.gain.linearRampToValueAtTime(0.001, now + duration); // Fade out over bomb duration

            // Stop the buffer source after the duration + a small buffer
            sizzleBufferSource.stop(now + duration + 0.1);
        }


        // Show message box until user interacts to enable audio
        messageBox.style.display = 'flex';
        document.body.addEventListener('click', initializeAudio, { once: true });


        // --- WebGL Setup ---
        let shaderProgram;
        let positionBuffer;
        let colorBuffer;
        let u_resolution;
        let u_transformMatrix;

        // Vertex shader program
        const vsSource = `
            attribute vec2 a_position;
            attribute vec4 a_color;
            uniform vec2 u_resolution;
            uniform mat3 u_transformMatrix; // 3x3 matrix for 2D transformations

            varying vec4 v_color;

            void main() {
                // Apply transformation matrix
                vec3 transformedPosition = u_transformMatrix * vec3(a_position, 1.0);
                // convert the rectangle from pixels to clip space
                vec2 clipSpace = ((transformedPosition.xy / u_resolution) * 2.0) - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); // Flip Y
                v_color = a_color;
            }
        `;

        // Fragment shader program
        const fsSource = `
            precision mediump float;
            varying vec4 v_color;

            void main() {
                gl_FragColor = v_color;
            }
        `;

        /**
         * Initializes a shader program, so WebGL knows how to draw our data.
         * @param {WebGLRenderingContext} gl The WebGL rendering context.
         * @param {string} vsSource The vertex shader source code.
         * @param {string} fsSource The fragment shader source code.
         * @returns {WebGLProgram} The compiled and linked shader program.
         */
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        /**
         * Creates a shader of the given type, uploads the source and compiles it.
         * @param {WebGLRenderingContext} gl The WebGL rendering context.
         * @param {number} type The type of shader (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER).
         * @param {string} source The shader source code.
         * @returns {WebGLShader} The compiled shader.
         */
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        /**
         * Initializes WebGL, creates shaders, and sets up buffers.
         * @returns {boolean} True if WebGL initialized successfully, false otherwise.
         */
        function initWebGL() {
            if (!gl) {
                console.error('Unable to initialize WebGL. Your browser or machine may not support it.');
                return false;
            }

            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            if (!shaderProgram) return false;

            gl.useProgram(shaderProgram);

            // Look up attribute and uniform locations
            shaderProgram.a_position = gl.getAttribLocation(shaderProgram, 'a_position');
            shaderProgram.a_color = gl.getAttribLocation(shaderProgram, 'a_color');
            u_resolution = gl.getUniformLocation(shaderProgram, 'u_resolution');
            u_transformMatrix = gl.getUniformLocation(shaderProgram, 'u_transformMatrix');

            // Create buffers
            positionBuffer = gl.createBuffer();
            colorBuffer = gl.createBuffer();

            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black, fully opaque
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Enable alpha blending

            return true;
        }

        /**
         * Sets up the buffers with vertex data for drawing.
         * @param {Float32Array} positions - Array of vertex positions.
         * @param {Float32Array} colors - Array of vertex colors (RGBA).
         */
        function setGeometry(positions, colors) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
        }

        /**
         * Draws a rectangle using WebGL.
         * @param {number} x - Top-left X coordinate.
         * @param {number} y - Top-left Y coordinate.
         * @param {number} width - Width of the rectangle.
         * @param {number} height - Height of the rectangle.
         * @param {number[]} color - RGBA color array [r, g, b, a].
         * @param {number} [rotation=0] - Rotation angle in radians around the center of the rectangle.
         * @param {number} [pivotX=x + width/2] - X coordinate of the rotation pivot.
         * @param {number} [pivotY=y + height/2] - Y coordinate of the rotation pivot.
         */
        function drawRect(x, y, width, height, color, rotation = 0, pivotX = x + width / 2, pivotY = y + height / 2) {
            const positions = new Float32Array([
                0, 0,
                width, 0,
                0, height,
                0, height,
                width, 0,
                width, height,
            ]);

            const colors = new Float32Array([
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
            ]);

            setGeometry(positions, colors);

            // Set up attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(shaderProgram.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.a_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(shaderProgram.a_color, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.a_color);

            // Set the resolution uniform
            gl.uniform2f(u_resolution, gl.canvas.width, gl.canvas.height);

            // Create and set the transform matrix
            let matrix = [
                1, 0, 0,
                0, 1, 0,
                x, y, 1, // Translate to position
            ];

            // Translate to pivot, rotate, translate back
            matrix = multiply(matrix, translation(-pivotX, -pivotY));
            matrix = multiply(matrix, rotationMatrix(rotation));
            matrix = multiply(matrix, translation(pivotX, pivotY));

            gl.uniformMatrix3fv(u_transformMatrix, false, matrix);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        /**
         * Draws a circle using WebGL.
         * @param {number} x - Center X coordinate.
         * @param {number} y - Center Y coordinate.
         * @param {number} radius - Radius of the circle.
         * @param {number[]} color - RGBA color array [r, g, b, a].
         * @param {number} [segments=32] - Number of segments to approximate the circle.
         */
        function drawCircle(x, y, radius, color, segments = 32) {
            const positions = [];
            const colors = [];

            // Center vertex
            positions.push(0, 0);
            colors.push(color[0], color[1], color[2], color[3]);

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                positions.push(radius * Math.cos(angle), radius * Math.sin(angle));
                colors.push(color[0], color[1], color[2], color[3]);
            }

            setGeometry(new Float32Array(positions), new Float32Array(colors));

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(shaderProgram.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.a_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(shaderProgram.a_color, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.a_color);

            gl.uniform2f(u_resolution, gl.canvas.width, gl.canvas.height);

            // Translate matrix to center of circle
            const matrix = [
                1, 0, 0,
                0, 1, 0,
                x, y, 1,
            ];
            gl.uniformMatrix3fv(u_transformMatrix, false, matrix);

            gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 2);
        }

        // --- 2D Matrix Functions (for WebGL transformations) ---
        function translation(tx, ty) {
            return [
                1, 0, 0,
                0, 1, 0,
                tx, ty, 1
            ];
        }

        function rotationMatrix(angleInRadians) {
            const c = Math.cos(angleInRadians);
            const s = Math.sin(angleInRadians);
            return [
                c, -s, 0,
                s, c, 0,
                0, 0, 1
            ];
        }

        function multiply(a, b) {
            const a00 = a[0 * 3 + 0];
            const a01 = a[0 * 3 + 1];
            const a02 = a[0 * 3 + 2];
            const a10 = a[1 * 3 + 0];
            const a11 = a[1 * 3 + 1];
            const a12 = a[1 * 3 + 2];
            const a20 = a[2 * 3 + 0];
            const a21 = a[2 * 3 + 1];
            const a22 = a[2 * 3 + 2];
            const b00 = b[0 * 3 + 0];
            const b01 = b[0 * 3 + 1];
            const b02 = b[0 * 3 + 2];
            const b10 = b[1 * 3 + 0];
            const b11 = b[1 * 3 + 1];
            const b12 = b[1 * 3 + 2];
            const b20 = b[2 * 3 + 0];
            const b21 = b[2 * 3 + 1];
            const b22 = b[2 * 3 + 2];

            return [
                a00 * b00 + a01 * b10 + a02 * b20,
                a00 * b01 + a01 * b11 + a02 * b21,
                a00 * b02 + a01 * b12 + a02 * b22,
                a10 * b00 + a11 * b10 + a12 * b20,
                a10 * b01 + a11 * b11 + a12 * b21,
                a10 * b02 + a11 * b12 + a12 * b22,
                a20 * b00 + a21 * b10 + a22 * b20,
                a20 * b01 + a21 * b11 + a22 * b21,
                a20 * b02 + a21 * b12 + a22 * b22,
            ];
        }


        // --- Utility Functions ---

        /**
         * Resizes the canvas to fit its parent container and maintain aspect ratio.
         */
        function resizeCanvas() {
            const parent = canvas.parentElement;
            const aspectRatio = 1; // 1:1 aspect ratio (600/600)
            let newWidth = parent.clientWidth;
            let newHeight = newWidth / aspectRatio;

            // Constrain height if it's too large for the window
            const maxAllowedHeight = window.innerHeight * 0.7; // Max 70% of window height
            if (newHeight > maxAllowedHeight) {
                newHeight = maxAllowedHeight;
                newWidth = newHeight * aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Scale factor for drawing elements
            // We'll scale all coordinates and sizes based on the new canvas size.
            // Using a base size of 600 for scaling, as original logic was for 600x600.
            const baseSize = 600;
            window.scaleFactor = canvas.width / baseSize;

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        /**
         * Converts an HSL color string to an RGBA array [r, g, b, a].
         * @param {string} hsl - HSL color string (e.g., "hsl(120, 100%, 50%)").
         * @param {number} [alpha=1] - Alpha value (0-1).
         * @returns {number[]} RGBA color array.
         */
        function hslToRgbA(hsl, alpha = 1) {
            const parts = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!parts) return [1, 0, 0, alpha]; // Default to red if invalid

            let h = parseInt(parts[1]);
            let s = parseInt(parts[2]) / 100;
            let l = parseInt(parts[3]) / 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            r = (r + m);
            g = (g + m);
            b = (b + m);

            return [r, g, b, alpha];
        }

        /**
         * Converts an RGB hex string to an RGBA array [r, g, b, a].
         * @param {string} hex - Hex color string (e.g., "#RRGGBB").
         * @param {number} [alpha=1] - Alpha value (0-1).
         * @returns {number[]} RGBA color array.
         */
        function hexToRgbA(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            // Handle #RGB and #RRGGBB
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return [r / 255, g / 255, b / 255, alpha];
        }

        /**
         * Draws the game background: cyan/black sky and green/dark gray grass.
         */
        function drawBackground() {
            const grassHeightRatio = 0.2; // 20% of canvas height for grass
            const grassHeight = canvas.height * grassHeightRatio;
            const skyHeight = canvas.height - grassHeight;

            let skyColor, grassColor;
            if (isDarkMode) {
                skyColor = hexToRgbA("#000000"); // Black
                grassColor = hexToRgbA("#1a1a1a"); // Dark gray
            } else {
                skyColor = hexToRgbA("#00FFFF"); // Cyan
                grassColor = hexToRgbA("#7CFC00"); // Green
            }

            // Draw sky
            drawRect(0, 0, canvas.width, skyHeight, skyColor);

            // Draw grass
            drawRect(0, skyHeight, canvas.width, grassHeight, grassColor);
        }

        /**
         * Draws a dark gray border around the playable area.
         */
        function drawBorder() {
            const borderWidth = 20 * window.scaleFactor; // Scaled border width
            const playableAreaX = borderWidth;
            const playableAreaY = borderWidth;
            const playableAreaWidth = canvas.width - (2 * borderWidth);
            const playableAreaHeight = canvas.height - (2 * borderWidth);

            const borderColor = hexToRgbA("#666666");

            // Draw top border
            drawRect(0, 0, canvas.width, playableAreaY, borderColor);
            // Draw bottom border
            drawRect(0, canvas.height - playableAreaY, canvas.width, playableAreaY, borderColor);
            // Draw left border
            drawRect(0, playableAreaY, playableAreaX, playableAreaHeight, borderColor);
            // Draw right border
            drawRect(canvas.width - playableAreaX, playableAreaY, playableAreaX, playableAreaHeight, borderColor);

            // Redraw the inner playable area to ensure correct background colors are visible
            const grassHeightRatio = 0.2;
            const grassHeight = canvas.height * grassHeightRatio;
            const skyHeight = canvas.height - grassHeight;

            let skyColor, grassColor;
            if (isDarkMode) {
                skyColor = hexToRgbA("#000000"); // Black
                grassColor = hexToRgbA("#1a1a1a"); // Dark gray
            } else {
                skyColor = hexToRgbA("#00FFFF"); // Cyan
                grassColor = hexToRgbA("#7CFC00"); // Green
            }

            // Draw sky for playable area
            drawRect(playableAreaX, playableAreaY, playableAreaWidth, skyHeight - playableAreaY, skyColor);
            // Draw grass for playable area
            drawRect(playableAreaX, skyHeight, playableAreaWidth, playableAreaHeight - (skyHeight - playableAreaY), grassColor);
        }


        /**
         * Calculates the new position of a point after rotation around a pivot.
         * Used to find the cannonball's starting position correctly.
         * @param {number} x - Original X coordinate of the point (unscaled).
         * @param {number} y - Original Y coordinate of the point (unscaled).
         * @returns {{x: number, y: number}} The new rotated and scaled coordinates.
         */
        function sortBallPos(x, y) {
            let rotatedAngle = angle; // Use the original angle for physics calculation
            // Cannon pivot is (cannon.x, cannon.y) in unscaled coordinates (center of barrel)
            const pivotX_unscaled = cannon.x;
            const pivotY_unscaled = cannon.y;

            // Scale the original point to be rotated and the pivot
            const scaledX = x * window.scaleFactor;
            const scaledY = y * window.scaleFactor;
            const pivotX_scaled = pivotX_unscaled * window.scaleFactor;
            const pivotY_scaled = pivotY_unscaled * window.scaleFactor;

            // Apply rotation to the point around the scaled pivot
            let dx = scaledX - pivotX_scaled;
            let dy = scaledY - pivotY_scaled;

            let newX = pivotX_scaled + dx * Math.cos(rotatedAngle) - dy * Math.sin(rotatedAngle);
            let newY = pivotY_scaled + dx * Math.sin(rotatedAngle) + dy * Math.cos(rotatedAngle);

            return {
                x: newX,
                y: newY
            };
        }

        // --- Cannon Class ---
        class Cannon {
            constructor(x, y) {
                this.x = x; // Center X of the cannon barrel (unscaled)
                this.y = y; // Center Y of the cannon barrel (unscaled)
                this.width = 100; // Unscaled width
                this.height = 50; // Unscaled height
            }

            /**
             * Draws the cannon barrel with a dithered pattern and a light tan firing end.
             */
            draw() {
                const scaledWidth = this.width * window.scaleFactor;
                const scaledHeight = this.height * window.scaleFactor;
                const pivotX_scaled = this.x * window.scaleFactor;
                const pivotY_scaled = this.y * window.scaleFactor;

                if (mousePos) {
                    // Revert to original angle calculation for correct physics
                    angle = Math.atan2(mousePos.y - pivotY_scaled, mousePos.x - pivotX_scaled);
                }

                // Main barrel (solid brown for WebGL simplification)
                const barrelColor = hexToRgbA("#A0522D"); // SaddleBrown
                drawRect(
                    pivotX_scaled - scaledWidth / 2, // X for top-left corner
                    pivotY_scaled - scaledHeight / 2, // Y for top-left corner
                    scaledWidth, scaledHeight,
                    barrelColor,
                    -angle, // Negate angle for visual rotation to correct for Y-axis inversion
                    pivotX_scaled, pivotY_scaled // Pivot at its center
                );

                // Light tan firing end
                const tanLength = 15 * window.scaleFactor;
                const tanColor = hexToRgbA("#F5DEB3"); // Light tan

                // The tan piece's top-left corner, relative to the cannon's pivot (this.x, this.y)
                // Its left edge should align with the right edge of the barrel (scaledWidth / 2)
                // Its top edge should align with the barrel's top edge (-scaledHeight / 2)
                const tanLocalX = scaledWidth / 2;
                const tanLocalY = -scaledHeight / 2;

                drawRect(
                    pivotX_scaled + tanLocalX, // X for top-left corner (relative to pivot, then add pivot)
                    pivotY_scaled + tanLocalY, // Y for top-left corner (relative to pivot, then add pivot)
                    tanLength, scaledHeight,
                    tanColor,
                    -angle, // Negate angle for visual rotation to correct for Y-axis inversion
                    pivotX_scaled, pivotY_scaled // Pivot at the cannon's main center
                );
            }

            /**
             * Updates the cannon's position based on keyboard input.
             */
            update() {
                // Cannon's X position is the center of the barrel
                const minCannonX = 20 + this.width / 2; // Left border + half width
                const maxCannonX = 600 - 20 - this.width / 2; // Right border - half width

                if (keysPressed['arrowleft'] || keysPressed['a']) {
                    this.x -= cannonMoveSpeed / window.scaleFactor; // Unscale speed for internal logic
                }
                if (keysPressed['arrowright'] || keysPressed['d']) {
                    this.x += cannonMoveSpeed / window.scaleFactor; // Unscale speed for internal logic
                }

                // Clamp cannon position to stay within bounds
                this.x = Math.max(minCannonX, Math.min(maxCannonX, this.x));
            }
        }

        // Initialize cannon:
        // Cannon width = 100, height = 50 (unscaled)
        // Canvas height = 600, border = 20 (unscaled)
        // Bottom of playable area = 600 - 20 = 580 (unscaled)
        // Cannon's center Y (this.y) = 580 - (cannon.height / 2) - 12 (gap) = 580 - 25 - 12 = 543 (unscaled)
        let cannon = new Cannon(130, 543);


        // --- CannonBall Class ---
        class CannonBall {
            constructor(angle, x, y, type = 'normal') { // type can be 'normal', 'mortar', 'bomb'
                this.radius = 15; // Unscaled radius
                this.mass = this.radius;
                this.angle = angle; // This angle is the one calculated for physics (Y-down)
                this.x = x; // Already scaled X
                this.y = y; // Already scaled Y
                this.dx = Math.cos(angle) * shotPower * window.scaleFactor; // Scaled velocity based on shotPower
                this.dy = Math.sin(angle) * shotPower * window.scaleFactor; // Scaled velocity based on shotPower
                this.gravity = gravityValue * window.scaleFactor; // Scaled gravity based on gravityValue
                this.elasticity = 0.5;
                this.friction = 0.008;
                this.shouldAudio = true;
                this.timeDiff1 = null;
                this.timeDiff2 = null;

                this.type = type;
                this.explosionDelay = (type === 'bomb') ? 3 : 2; // 3 seconds for bomb, 2 for mortar
                this.bombStartTime = (type === 'mortar' || type === 'bomb') ? audioContext.currentTime : null;
                this.exploded = false;
                this.fuseParticles = []; // For fuse visual effect
            }

            /**
             * Moves the cannonball based on its velocity and gravity.
             */
            move() {
                // Sort out gravity
                const groundLevel = (580 - 20) * window.scaleFactor; // Scaled ground level adjusted for border
                if (this.y + (this.radius * window.scaleFactor) < groundLevel) {
                    this.dy += this.gravity;
                }

                // Apply friction to X axis
                this.dx = this.dx - (this.dx * this.friction);

                this.x += this.dx;
                this.y += this.dy;

                // Update fuse particles if it's a bomb or mortar
                if ((this.type === 'mortar' || this.type === 'bomb') && !this.exploded) {
                    this.updateFuse();
                }
            }

            /**
             * Draws the cannonball.
             */
            draw() {
                const scaledRadius = this.radius * window.scaleFactor;

                // Draw ball body
                if (this.type === 'bomb') {
                    // Black, shiny bomb
                    drawCircle(this.x, this.y, scaledRadius, hexToRgbA("#000000")); // Black

                    // Add a shiny highlight (simplified to a smaller white circle)
                    drawCircle(this.x - scaledRadius * 0.4, this.y - scaledRadius * 0.4, scaledRadius * 0.6, hexToRgbA("#FFFFFF", 0.3));

                } else {
                    // Gray for normal/mortar balls
                    drawCircle(this.x, this.y, scaledRadius, hexToRgbA("#888888")); // Gray
                }

                // Draw fuse if it's a bomb or mortar and not exploded
                if ((this.type === 'mortar' || this.type === 'bomb') && !this.exploded) {
                    this.drawFuse();
                }
            }

            /**
             * Updates the fuse particles for a bomb/mortar.
             */
            updateFuse() {
                const scaledRadius = this.radius * window.scaleFactor;

                // Calculate fuse tip position (behind the ball, relative to its movement angle)
                let currentFuseLength = (this.type === 'bomb' ? 3 : 2) * window.scaleFactor;
                if (this.type === 'bomb' && audioContext && this.bombStartTime) {
                    const elapsed = audioContext.currentTime - this.bombStartTime;
                    currentFuseLength = currentFuseLength * (1 - (elapsed / this.explosionDelay));
                    currentFuseLength = Math.max(0, currentFuseLength);
                }

                // Fuse starts at the back edge of the ball
                // We need to calculate the point on the circumference directly opposite to the firing direction
                const fuseStartAngle = this.angle + Math.PI; // Opposite direction of travel
                const fuseStartX = this.x + Math.cos(fuseStartAngle) * scaledRadius;
                const fuseStartY = this.y + Math.sin(fuseStartAngle) * scaledRadius;

                // Fuse tip is at the end of the current fuse length, extending straight from the back of the ball
                const fuseTipX = fuseStartX + Math.cos(fuseStartAngle) * currentFuseLength;
                const fuseTipY = fuseStartY + Math.sin(fuseStartAngle) * currentFuseLength;


                // Add new particles from the fuse tip
                if (Math.random() < 0.7) { // Chance to spawn a new particle
                    const angleOffset = (Math.random() - 0.5) * Math.PI / 4; // Small random angle around the back
                    const particleAngle = fuseStartAngle + angleOffset; // Sparks emit backward from fuse tip
                    const particleSpeed = (Math.random() * 2 + 1) * window.scaleFactor;

                    let particleColor;
                    if (this.type === 'bomb') {
                        // Red, yellow, orange for bomb sparks
                        // Convert HSL to RGBA for WebGL
                        particleColor = hslToRgbA(`hsl(${Math.random() * 30 + 30}, 100%, 50%)`);
                    } else { // Mortar sparks
                        // Randomized random bright colors for mortar sparks
                        particleColor = hslToRgbA(`hsl(${Math.random() * 360}, 100%, 50%)`);
                    }

                    this.fuseParticles.push({
                        x: fuseTipX, // Particles start exactly at the fuse tip
                        y: fuseTipY,
                        dx: Math.cos(particleAngle) * particleSpeed,
                        dy: Math.sin(particleAngle) * particleSpeed,
                        size: (Math.random() * 3 + 1) * window.scaleFactor,
                        opacity: 1,
                        color: particleColor // Already RGBA array
                    });
                }

                // Update existing particles
                for (let i = this.fuseParticles.length - 1; i >= 0; i--) {
                    const p = this.fuseParticles[i];
                    p.x += p.dx;
                    p.y += p.dy;
                    p.opacity -= 0.05; // Fade out
                    p.size *= 0.95; // Shrink

                    if (p.opacity <= 0.1 || p.size <= 0.5) {
                        this.fuseParticles.splice(i, 1); // Remove faded particles
                    }
                }
            }

            /**
             * Draws the fuse and its particles.
             */
            drawFuse() {
                const scaledRadius = this.radius * window.scaleFactor;
                const fuseWidth = 3 * window.scaleFactor; // Used for visual thickness, not actual line drawing

                // Calculate fuse start and end points
                const fuseStartAngle = this.angle + Math.PI; // Opposite direction of travel
                const fuseStartX = this.x + Math.cos(fuseStartAngle) * scaledRadius;
                const fuseStartY = this.y + Math.sin(fuseStartAngle) * scaledRadius;

                let currentFuseLength = (this.type === 'bomb' ? 3 : 2) * window.scaleFactor;
                if (this.type === 'bomb' && audioContext && this.bombStartTime) {
                    const elapsed = audioContext.currentTime - this.bombStartTime;
                    currentFuseLength = ((this.type === 'bomb' ? 3 : 2) * window.scaleFactor) * (1 - (elapsed / this.explosionDelay));
                    currentFuseLength = Math.max(0, currentFuseLength);
                }

                const fuseEndX = fuseStartX + Math.cos(fuseStartAngle) * currentFuseLength;
                const fuseEndY = fuseStartY + Math.sin(fuseStartAngle) * currentFuseLength;

                // Draw the fuse line as a thin rectangle for WebGL
                const fuseColor = hexToRgbA("#D2B48C"); // Tan color
                // Calculate the center and dimensions of the rectangle
                const fuseCenterX = (fuseStartX + fuseEndX) / 2;
                const fuseCenterY = (fuseStartY + fuseEndY) / 2;
                const fuseActualLength = Math.sqrt(Math.pow(fuseEndX - fuseStartX, 2) + Math.pow(fuseEndY - fuseStartY, 2));

                drawRect(
                    fuseCenterX - fuseActualLength / 2, // X for top-left of unrotated rect
                    fuseCenterY - fuseWidth / 2,      // Y for top-left of unrotated rect
                    fuseActualLength, fuseWidth,
                    fuseColor,
                    fuseStartAngle, // Angle of the fuse
                    fuseCenterX, fuseCenterY // Pivot around its center
                );


                // Draw fuse particles (sparks) as small circles
                this.fuseParticles.forEach(p => {
                    // p.color is already an RGBA array
                    drawCircle(p.x, p.y, p.size / 2, [p.color[0], p.color[1], p.color[2], p.opacity]);
                });
            }
        }

        // --- Explosion Piece Class ---
        class ExplosionPiece {
            constructor(x, y, dx, dy, size, color, isChunk = false) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.size = size; // Scaled size
                this.color = color; // RGBA array
                this.opacity = 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2; // Random spin direction and speed
                this.gravity = gravityValue * window.scaleFactor; // Inherit current gravity
                this.isChunk = isChunk; // True if it's a black chunk
                this.elasticity = isChunk ? 0.4 : 0.5; // Chunks might bounce a bit less
            }

            move() {
                this.dy += this.gravity;
                this.x += this.dx;
                this.y += this.dy;
                this.rotation += this.rotationSpeed;
                // Chunks do not fade, other pieces fade
                if (!this.isChunk) {
                    this.opacity -= 0.02;
                }
            }

            draw() {
                // Use the stored RGBA color, applying current opacity
                drawRect(
                    this.x - this.size / 2,
                    this.y - this.size / 2,
                    this.size, this.size,
                    [this.color[0], this.color[1], this.color[2], Math.max(0, this.opacity)],
                    this.rotation,
                    this.x, this.y // Pivot around its center
                );
            }
        }

        /**
         * Triggers an explosion effect at a given ball's position.
         * @param {CannonBall} ball - The ball that is exploding.
         */
        function triggerExplosion(ball) {
            playExplosionSound();

            const numFirePieces = 10 + Math.floor(Math.random() * 5); // 10-14 pieces
            for (let j = 0; j < numFirePieces; j++) {
                const speed = (Math.random() * 5 + 2) * window.scaleFactor;
                const pieceAngle = Math.random() * Math.PI * 2;

                let pieceColor;
                if (ball.type === 'mortar') {
                    // Random bright colors for mortar explosions (HSL to RGBA)
                    pieceColor = hslToRgbA(`hsl(${Math.random() * 360}, 100%, 50%)`);
                } else {
                    // Red to yellow colors for bombs (default fire) (HSL to RGBA)
                    pieceColor = hslToRgbA(`hsl(${Math.random() * 60}, 100%, 50%)`);
                }

                explosionPieces.push(new ExplosionPiece(
                    ball.x,
                    ball.y,
                    Math.cos(pieceAngle) * speed,
                    Math.sin(pieceAngle) * speed,
                    (Math.random() * 5 + 3) * window.scaleFactor,
                    pieceColor,
                    false // Not a chunk
                ));
            }

            if (ball.type === 'bomb') {
                const numChunks = 5 + Math.floor(Math.random() * 3); // 5-7 black chunks
                for (let j = 0; j < numChunks; j++) {
                    const chunkSpeed = (Math.random() * 8 + 4) * window.scaleFactor; // Higher force
                    const chunkAngle = Math.random() * Math.PI * 2;
                    explosionPieces.push(new ExplosionPiece(
                        ball.x,
                        ball.y,
                        Math.cos(chunkAngle) * chunkSpeed,
                        Math.sin(chunkAngle) * chunkSpeed,
                        (Math.random() * 8 + 5) * window.scaleFactor, // Larger chunk size
                        hexToRgbA("#000000"), // Black color (RGBA)
                        true // Mark as a chunk
                    ));
                }
            }
        }


        /**
         * Checks if a cannonball has hit any of the canvas borders and handles collision.
         * @param {CannonBall} ball - The cannonball to check.
         * @returns {boolean} True if the ball should be removed (e.g., mortar explosion), false otherwise.
         */
        function ballHitWall(ball) {
            const scaledRadius = ball.radius * window.scaleFactor;
            const border = 20 * window.scaleFactor; // Scaled border size
            const rightWall = canvas.width - border;
            const leftWall = border;
            const bottomWall = canvas.height - border;
            const topWall = border;

            // A collision has occurred on any side of the canvas
            if (ball.x + scaledRadius > rightWall ||
                ball.x - scaledRadius < leftWall ||
                ball.y + scaledRadius > bottomWall ||
                ball.y - scaledRadius < topWall) {

                // If it's a mortar, trigger explosion immediately
                if (ball.type === 'mortar' && !ball.exploded) {
                    ball.exploded = true; // Mark as exploded
                    ball.dx = 0; // Stop movement
                    ball.dy = 0;
                    ball.radius = 0; // Make it invisible immediately
                    triggerExplosion(ball); // Trigger mortar explosion
                    return true; // Indicate that the ball should be removed/handled
                }

                if (ball.timeDiff1) {
                    ball.timeDiff2 = new Date().getTime() - ball.timeDiff1;
                    // Prevent rapid re-triggering of sound if multiple collisions happen too fast
                    ball.shouldAudio = ball.timeDiff2 >= 200;
                } else {
                    ball.shouldAudio = true;
                }

                if (ball.shouldAudio) {
                    playCollisionSound(); // Play collision sound
                }

                // Sort out elasticity & then change direction
                ball.dy = (ball.dy * ball.elasticity);

                // Right side of ball hits right side of canvas
                if (ball.x + scaledRadius > rightWall) {
                    // We set the X & Y coordinates first to prevent ball from getting stuck in the canvas border
                    ball.x = rightWall - scaledRadius;
                    ball.dx *= -1;
                } else if (ball.x - scaledRadius < leftWall) {
                    // Left side of ball hits left side of canvas
                    ball.x = leftWall + scaledRadius;
                    ball.dx *= -1;
                } else if (ball.y + scaledRadius > bottomWall) {
                    // Bottom of ball hits bottom of canvas
                    ball.y = bottomWall - scaledRadius;
                    ball.dy *= -1;
                } else if (ball.y - scaledRadius < topWall) {
                    // Top of ball hits top of canvas
                    ball.y = topWall + scaledRadius;
                    ball.dy *= -1;
                }

                ball.timeDiff1 = new Date().getTime();
            }
            return false; // No immediate removal needed for non-mortars
        }

        /**
         * Checks for collision between two cannonballs.
         * @param {CannonBall} ball1 - The first cannonball.
         * @param {CannonBall} ball2 - The second cannonball.
         * @returns {boolean} True if a collision occurred, false otherwise.
         */
        function ballHitBall(ball1, ball2) {
            let dx = ball1.x - ball2.x;
            let dy = ball1.y - ball2.y;
            // Modified Pythagorean theorem, because sqrt is slow
            let distanceSq = (dx * dx + dy * dy);
            const scaledRadius1 = ball1.radius * window.scaleFactor;
            const scaledRadius2 = ball2.radius * window.scaleFactor;
            if (distanceSq <= (scaledRadius1 + scaledRadius2) * (scaledRadius1 + scaledRadius2)) {
                return true;
            }
            return false;
        }

        /**
         * Resolves collision between two cannonballs.
         * @param {CannonBall} ball1 - The first cannonball.
         * @param {CannonBall} ball2 - The second cannonball.
         */
        function collideBalls(ball1, ball2) {
            // It matters that we are getting the exact difference from ball 1 & ball 2
            let dx = ball2.x - ball1.x;
            let dy = ball2.y - ball1.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            // Work out the normalized collision vector (direction only)
            let vCollisionNorm = { x: dx / distance, y: dy / distance };
            // Relative velocity of ball 2
            let vRelativeVelocity = { x: ball1.dx - ball2.dx, y: ball1.dy - ball2.dy };
            // Calculate the dot product
            let speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;

            // Don't do anything because balls are already moving out of each other's way
            if (speed < 0) return;

            let impulse = 2 * speed / (ball1.mass + ball2.mass);
            // Because we calculated the relative velocity of ball2. Ball1 needs to go in the opposite direction, hence a collision.
            ball1.dx -= (impulse * ball2.mass * vCollisionNorm.x);
            ball1.dy -= (impulse * ball2.mass * vCollisionNorm.y);
            ball2.dx += (impulse * ball1.mass * vCollisionNorm.x);
            ball2.dy += (impulse * ball1.mass * vCollisionNorm.y);

            // Still have to account for elasticity
            ball1.dy = (ball1.dy * ball1.elasticity);
            ball2.dy = (ball2.dy * ball2.elasticity);

            // Play collision sound for ball-ball collision
            playCollisionSound();
        }

        /**
         * Checks for and resolves collisions between a given ball and all subsequent balls in the array.
         * @param {number} index - The index of the current ball to check.
         */
        function collide(index) {
            let ball = cannonBalls[index];
            for (let j = index + 1; j < cannonBalls.length; j++) {
                let testBall = cannonBalls[j];
                if (ballHitBall(ball, testBall)) {
                    collideBalls(ball, testBall);
                }
            }
        }

        /**
         * Handles shooting a cannonball.
         */
        function shootCannonBall() {
            // Angle range: No clamping for firing arc. The physics will handle collisions.
            // The visual rotation is 360, and now firing can also be 360.

            if (!canShoot) return; // If cannon is on cooldown, do nothing
            canShoot = false; // Set cooldown

            // Determine ball type
            let ballType = 'normal';
            if (isMortarMode) {
                ballType = 'mortar';
            } else if (isBombMode) {
                ballType = 'bomb';
            }

            // Calculate the cannonball's starting position based on cannon's nozzle
            // Nozzle is at the right end of the barrel
            let ballStartX_unscaled = cannon.x + cannon.width / 2;
            let ballStartY_unscaled = cannon.y; // Center Y of the barrel

            let ballPos = sortBallPos(ballStartX_unscaled, ballStartY_unscaled);

            // Add a new cannonball to the array
            cannonBalls.push(
                new CannonBall(angle, ballPos.x, ballPos.y, ballType)
            );

            playCannonSound(); // Play cannon sound

            // If it's a bomb, start the sizzle sound
            if (ballType === 'bomb') {
                // Ensure audio context is ready before starting sizzle
                if (audioContext && audioContext.state === 'running') {
                    startSizzleSound(cannonBalls[cannonBalls.length - 1].explosionDelay);
                }
            }

            // Set a timeout for the cannon cooldown based on fireRateDelay
            setTimeout(() => {
                canShoot = true;
            }, fireRateDelay);
        }

        /**
         * The main animation loop of the game. Clears canvas, draws elements, updates physics.
         */
        function animate() {
            requestAnimationFrame(animate);

            // Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Draw background first
            drawBackground();
            // Draw Border
            drawBorder();

            // Update and draw cannon
            cannon.update(); // Update cannon position
            cannon.draw();

            // Update and draw cannon balls
            for (let i = cannonBalls.length - 1; i >= 0; i--) {
                let ball = cannonBalls[i];
                // Moves the balls
                ball.move();
                // If ballHitWall returns true, it means a mortar exploded and should be removed
                if (ballHitWall(ball)) {
                    cannonBalls.splice(i, 1);
                    continue; // Move to the next ball
                }
                collide(i); // Check for ball-ball collisions

                // Check for bomb/mortar explosion (timed)
                if ((ball.type === 'mortar' || ball.type === 'bomb') && !ball.exploded && audioContext && ball.bombStartTime && audioContext.currentTime - ball.bombStartTime >= ball.explosionDelay) {
                    ball.exploded = true;
                    triggerExplosion(ball); // Trigger explosion
                    cannonBalls.splice(i, 1); // Remove the bomb/mortar
                } else {
                    // Renders balls to canvas if not exploded
                    ball.draw();
                }
            }

            // Update and draw explosion pieces
            for (let i = explosionPieces.length - 1; i >= 0; i--) {
                let piece = explosionPieces[i];
                piece.move();
                piece.draw();
                // Remove pieces that have faded out or gone off screen
                const border = 20 * window.scaleFactor;
                // Chunks (isChunk=true) only disappear if they go off-screen. Other pieces fade.
                const shouldRemove = (piece.isChunk && (piece.y > canvas.height - border || piece.x < border || piece.x > canvas.width - border)) ||
                                     (!piece.isChunk && (piece.opacity <= 0.05 || piece.y > canvas.height - border || piece.x < border || piece.x > canvas.width - border));
                if (shouldRemove) {
                    explosionPieces.splice(i, 1);
                }
            }

            // Enforce MAX_EXPLOSION_PIECES limit
            while (explosionPieces.length > MAX_EXPLOSION_PIECES) {
                explosionPieces.shift(); // Remove the oldest piece
            }
        }

        // --- Event Listeners ---

        // Mouse has moved on the canvas
        canvas.addEventListener("mousemove", e => {
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            mousePos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });

        // Mouse click on the canvas to shoot
        canvas.addEventListener("click", shootCannonBall);

        // Keyboard input for cannon movement and shooting
        window.addEventListener("keydown", e => {
            keysPressed[e.key.toLowerCase()] = true;
            if (e.key === ' ' || e.key === 'Spacebar') { // Spacebar
                e.preventDefault(); // Prevent default scroll behavior for spacebar
                shootCannonBall();
            }
        });

        window.addEventListener("keyup", e => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        // Handle window resize to make the canvas responsive
        window.addEventListener('resize', resizeCanvas);

        // Settings Sliders Event Listeners
        shotPowerSlider.addEventListener('input', (e) => {
            shotPower = parseFloat(e.target.value);
            shotPowerValueSpan.textContent = shotPower.toFixed(1);
        });

        fireRateSlider.addEventListener('input', (e) => {
            fireRateDelay = parseInt(e.target.value);
            fireRateValueSpan.textContent = (fireRateDelay / 1000).toFixed(1) + " sec";
        });

        gravitySlider.addEventListener('input', (e) => {
            gravityValue = parseFloat(e.target.value);
            gravityValueSpan.textContent = gravityValue.toFixed(2);
        });

        muteAudioToggle.addEventListener('change', (e) => {
            isMuted = e.target.checked;
            // Suspend/resume audio context for full mute
            if (audioContext) {
                if (isMuted) {
                    audioContext.suspend();
                } else {
                    audioContext.resume();
                }
            }
        });

        mortarToggle.addEventListener('change', (e) => {
            isMortarMode = e.target.checked;
            if (isMortarMode && isBombMode) { // Only one special mode at a time
                bombToggle.checked = false;
                isBombMode = false;
            }
        });

        bombToggle.addEventListener('change', (e) => {
            isBombMode = e.target.checked;
            if (isBombMode && isMortarMode) { // Only one special mode at a time
                mortarToggle.checked = false;
                isMortarMode = false;
            }
        });

        darkModeToggle.addEventListener('change', (e) => {
            isDarkMode = e.target.checked;
            // Redraw everything to apply new background/border colors
            drawBackground();
            drawBorder();
            // No need to redraw cannon/balls/explosion pieces here, they are redrawn in animate loop
        });


        // Restart Button
        restartBtn.addEventListener('click', () => {
            cannonBalls = []; // Clear the array
            explosionPieces = []; // Clear any lingering explosion pieces too
            // Stop any active sizzle sound if bombs are cleared
            if (sizzleBufferSource) {
                try {
                    sizzleBufferSource.stop();
                    sizzleBufferSource = null; // Set to null after stopping
                } catch (e) {
                    // Already stopped or disconnected
                }
            }
        });


        // --- Game Initialization ---
        window.onload = function () {
            if (!initWebGL()) {
                // If WebGL fails, maybe provide a fallback message or disable game.
                messageBox.innerHTML = '<p>Your browser does not support WebGL, or there was an error initializing it. This game requires WebGL.</p>';
                messageBox.style.display = 'flex';
                return;
            }

            // Set initial values for sliders and toggles based on HTML attributes
            shotPowerValueSpan.textContent = shotPowerSlider.value;
            fireRateValueSpan.textContent = (fireRateSlider.value / 1000).toFixed(1) + " sec";
            gravityValueSpan.textContent = gravitySlider.value;
            mortarToggle.checked = true; // Set mortar to default checked

            resizeCanvas(); // Initial canvas resize
            animate(); // Start the animation loop
        };
    </script>
</body>
</html>
